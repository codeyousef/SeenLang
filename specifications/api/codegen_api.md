# Semantic Analyzer-Code Generator Interface Specification

## Overview

This document specifies the interface between the Semantic Analyzer and the Code Generator components of the Seen programming language compiler. The Semantic Analyzer validates the AST generated by the parser and provides additional semantic information that the Code Generator uses to produce LLVM IR.

## Data Flow

```
Semantic Analyzer → Annotated AST → Code Generator → LLVM IR
```

## Annotated AST

The Semantic Analyzer produces an **Annotated AST**, which is the original AST from the parser with the following additional information:

1. **Type Information**: Each expression node is annotated with its inferred or declared type.
2. **Symbol Resolution**: Identifiers are annotated with information about what they refer to (variable, function, etc.).
3. **Scope Information**: Variable declarations are associated with their scope level.
4. **Constant Evaluation**: Expressions that can be evaluated at compile-time are marked accordingly.

## Interface Structure

### Input to Code Generator

The Code Generator takes as input:

1. **Annotated AST**: The AST with all semantic information attached.
2. **Symbol Table**: A collection of all symbols defined in the program and their properties.
3. **Compilation Context**: Information about the current compilation, including target details.

### Key Data Structures

#### AnnotatedProgram

```rust
pub struct AnnotatedProgram {
    pub declarations: Vec<AnnotatedDeclaration>,
    pub location: Location,
    pub symbol_table: SymbolTable,
}
```

#### AnnotatedDeclaration

```rust
pub enum AnnotatedDeclaration {
    Function(AnnotatedFunctionDeclaration),
    Variable(AnnotatedVariableDeclaration),
}
```

#### AnnotatedExpression

```rust
pub struct AnnotatedExpression {
    pub original: Expression,
    pub result_type: TypeInfo,
    pub is_constant: bool,
    pub constant_value: Option<Value>,
}
```

#### SymbolTable

```rust
pub struct SymbolTable {
    pub scopes: Vec<Scope>,
}

pub struct Scope {
    pub symbols: HashMap<String, Symbol>,
    pub parent: Option<usize>,  // Index of parent scope in the scopes vector
}

pub struct Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub type_info: TypeInfo,
    pub is_mutable: bool,
    pub is_initialized: bool,
    pub declaration_location: Location,
}

pub enum SymbolKind {
    Variable,
    Function,
    Parameter,
    Type,
}
```

#### TypeInfo

```rust
pub enum TypeInfo {
    Int,
    Float,
    Bool,
    String,
    Array(Box<TypeInfo>),
    Void,
    Function {
        parameters: Vec<TypeInfo>,
        return_type: Box<TypeInfo>,
    },
    Unknown,  // For error recovery
}
```

### Output from Code Generator

The Code Generator produces:

1. **LLVM Module**: Contains all the generated LLVM IR for the program.
2. **Diagnostics**: Any issues encountered during code generation.

### Functions

#### generate(program: AnnotatedProgram, context: CompilationContext) -> Result<LLVMModule, CodeGenError>

Main entry point for code generation. Takes an annotated program and compilation context, returns an LLVM module or error.

#### generate_declaration(declaration: &AnnotatedDeclaration) -> Result<(), CodeGenError>

Generates code for a declaration (either function or variable).

#### generate_function(function: &AnnotatedFunctionDeclaration) -> Result<FunctionValue, CodeGenError>

Generates code for a function declaration, including parameters and body.

#### generate_statement(statement: &AnnotatedStatement) -> Result<(), CodeGenError>

Generates code for a statement.

#### generate_expression(expression: &AnnotatedExpression) -> Result<BasicValueEnum, CodeGenError>

Generates code for an expression, returning an LLVM value.

## Error Handling

The Code Generator will report errors for the following conditions:

1. **Unsupported Operations**: Operations that cannot be applied to the given types.
2. **Memory Allocation Failures**: Failures to allocate memory for variables.
3. **LLVM Initialization Failures**: Problems setting up the LLVM context.
4. **Invalid LLVM IR**: Generated IR that fails verification.

Errors are structured as:

```rust
pub enum CodeGenError {
    UnsupportedOperation(String),
    MemoryAllocationFailure(String),
    LLVMInitializationFailure(String),
    InvalidIR(String),
    InternalError(String),
}
```

## Implementation Notes

1. **Type Compatibility**: The Code Generator relies on type information from the Semantic Analyzer to ensure operations are valid.
2. **Memory Management**: The Semantic Analyzer identifies when variables can be stack-allocated vs. heap-allocated.
3. **Optimization Hints**: The Semantic Analyzer can provide hints to the Code Generator about optimization opportunities.

## Example

Input from Semantic Analyzer:

```rust
// Annotated AST for a simple function
let annotated_function = AnnotatedFunctionDeclaration {
    name: "add",
    parameters: vec![
        AnnotatedParameter { name: "a", param_type: TypeInfo::Int, ... },
        AnnotatedParameter { name: "b", param_type: TypeInfo::Int, ... },
    ],
    return_type: Some(TypeInfo::Int),
    body: AnnotatedBlock { ... },
    ...
};
```

Output from Code Generator:

```llvm
; LLVM IR
define i64 @add(i64 %a, i64 %b) {
entry:
  %add_result = add i64 %a, %b
  ret i64 %add_result
}
```
