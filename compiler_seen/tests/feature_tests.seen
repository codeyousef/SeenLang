// Syntax Feature Tests
// Tests for all Seen language features from Syntax Design

use testing::assert::*;
use testing::runner::*;

// ============== VISIBILITY TESTS ==============

fun test_capitalization_visibility() {
    // Public items start with capital letters
    let publicNames = ["User", "ProcessData", "MaxValue", "HttpClient"];
    for name in publicNames {
        let firstChar = name.charAt(0);
        assertTrue(firstChar >= 'A' and firstChar <= 'Z', 
                  "Public item '{name}' should start with capital");
    }
    
    // Private items start with lowercase
    let privateNames = ["user", "processData", "maxValue", "httpClient"];
    for name in privateNames {
        let firstChar = name.charAt(0);
        assertTrue(firstChar >= 'a' and firstChar <= 'z',
                  "Private item '{name}' should start with lowercase");
    }
}

// ============== IMMUTABILITY TESTS ==============

fun test_immutable_by_default() {
    // Test that 'let' creates immutable bindings
    let immutableValue = 42;
    
    // The following should not compile (but we can't test compilation errors)
    // immutableValue = 43; // ERROR
    
    // Test that 'var' creates mutable bindings
    var mutableValue = 42;
    mutableValue = 43; // Should work
    
    assertEqualsInt(43, mutableValue, "Mutable variable should be modifiable");
}

// ============== NULLABLE TYPE TESTS ==============

fun test_nullable_types() {
    // Non-nullable type
    let user: String = "Alice";
    assertNotNull(user, "Non-nullable should not be null");
    
    // Nullable type
    let maybe: String? = null;
    assertNull(maybe, "Nullable can be null");
    
    // Nullable with value
    let maybeWithValue: String? = "Bob";
    assertNotNull(maybeWithValue, "Nullable can have value");
}

fun test_safe_navigation() {
    // Simulate user object
    let userName: String? = null;
    
    // Safe navigation should not crash
    // let length = userName?.length; // Would return null
    
    // Elvis operator provides default
    let displayName = userName ?: "Guest";
    assertEquals("Guest", displayName, "Elvis operator should provide default");
}

fun test_force_unwrap() {
    let value: String? = "Hello";
    
    // Force unwrap should work with non-null value
    // let unwrapped = value!!; // Would work
    
    // Smart casting
    if value != null {
        // Inside this block, value is smart-cast to non-nullable
        let length = value.length(); // No ?. needed
        assertGreaterThan(length, 0, "Smart cast should work");
    }
}

// ============== WORD OPERATOR TESTS ==============

fun test_word_operators() {
    let x = true;
    let y = false;
    
    // 'and' operator
    let andResult = x and y;
    assertFalse(andResult, "'and' operator should work");
    
    // 'or' operator
    let orResult = x or y;
    assertTrue(orResult, "'or' operator should work");
    
    // 'not' operator
    let notResult = not y;
    assertTrue(notResult, "'not' operator should work");
    
    // Complex expression
    let complex = (x and not y) or (not x and y);
    assertTrue(complex, "Complex logical expression should work");
}

// ============== STRING INTERPOLATION TESTS ==============

fun test_string_interpolation() {
    let name = "Alice";
    let age = 30;
    
    // Basic interpolation
    let greeting = "Hello, {name}!";
    assertContains(greeting, "Alice", "String interpolation should work");
    
    // Multiple interpolations
    let message = "{name} is {age} years old";
    assertContains(message, "Alice", "Should interpolate first variable");
    assertContains(message, "30", "Should interpolate second variable");
    
    // Expression interpolation
    let calc = "2 + 2 = {2 + 2}";
    assertContains(calc, "4", "Should interpolate expressions");
    
    // Literal braces
    let literal = "Use {{braces}} for literal { and }";
    assertContains(literal, "{braces}", "Double braces should produce literal");
}

// ============== RANGE OPERATOR TESTS ==============

fun test_range_operators() {
    // Inclusive range
    let inclusive = [];
    for i in 1..3 {
        inclusive.append(i);
    }
    assertEqualsInt(3, inclusive.size(), "Inclusive range should include end");
    
    // Exclusive range
    let exclusive = [];
    for i in 1..<3 {
        exclusive.append(i);
    }
    assertEqualsInt(2, exclusive.size(), "Exclusive range should exclude end");
}

// ============== EXPRESSION TESTS ==============

fun test_everything_is_expression() {
    // If expression
    let status = if true { "active" } else { "inactive" };
    assertEquals("active", status, "If should be an expression");
    
    // Block expression
    let result = {
        let x = 10;
        let y = 20;
        x + y  // Last expression is the value
    };
    assertEqualsInt(30, result, "Block should be an expression");
    
    // Match expression (if supported)
    let value = 2;
    let category = if value == 0 {
        "zero"
    } else if value < 5 {
        "small"
    } else {
        "large"
    };
    assertEquals("small", category, "Chained if should work as expression");
}

// ============== COLLECTION LITERAL TESTS ==============

fun test_collection_literals() {
    // Array literal
    let array = [1, 2, 3, 4, 5];
    assertEqualsInt(5, array.size(), "Array literal should work");
    assertEqualsInt(1, array[0], "Array indexing should work");
    
    // Map literal
    let map = {"name": "Alice", "age": "30"};
    assertEquals("Alice", map["name"], "Map literal should work");
    
    // Set literal
    let set = {1, 2, 3, 2, 1}; // Duplicates should be removed
    // Set would have 3 unique elements
    
    // Empty literals
    let emptyArray = [];
    let emptyMap = {:};
    let emptySet = {};
    
    assertEqualsInt(0, emptyArray.size(), "Empty array should work");
}

// ============== MEMORY MANAGEMENT TESTS ==============

fun test_memory_keywords() {
    // These tests verify the syntax is recognized
    // Actual memory behavior would need runtime testing
    
    let data = "some data";
    
    // Move semantics (syntax test only)
    // let moved = move data;
    // data would no longer be accessible
    
    // Borrow semantics (syntax test only)
    // let borrowed = borrow data;
    // data still accessible
    
    // Mutable borrow (syntax test only)
    // let mutBorrowed = borrow mut data;
    
    // Region-based memory (syntax test only)
    // region fastMemory {
    //     let temp = allocate(1024);
    // } // Memory freed here
    
    assertTrue(true, "Memory keywords syntax recognized");
}

// ============== PATTERN MATCHING TESTS ==============

fun test_pattern_matching() {
    let value = 5;
    
    // Simple pattern matching with if
    let result = if value == 0 {
        "zero"
    } else if value > 0 and value < 10 {
        "single digit"
    } else if value >= 10 and value < 100 {
        "double digit"
    } else {
        "large"
    };
    
    assertEquals("single digit", result, "Pattern matching should work");
}

// ============== TYPE SYSTEM TESTS ==============

fun test_type_inference() {
    // Type inference from literals
    let integer = 42;        // Inferred as Int
    let floating = 3.14;     // Inferred as Float
    let text = "hello";      // Inferred as String
    let boolean = true;      // Inferred as Bool
    
    // Type inference from expressions
    let sum = integer + 8;   // Inferred as Int
    let concat = text + " world"; // Inferred as String
    
    assertTrue(true, "Type inference should work");
}

// ============== TEST SUITE SETUP ==============

fun createFeatureTestSuite() -> TestSuite {
    let suite = TestSuite::new("Language Features");
    
    // Visibility tests
    suite.test("Capitalization-based visibility", test_capitalization_visibility);
    
    // Immutability tests
    suite.test("Immutable by default", test_immutable_by_default);
    
    // Nullable type tests
    suite.test("Nullable types", test_nullable_types);
    suite.test("Safe navigation", test_safe_navigation);
    suite.test("Force unwrap", test_force_unwrap);
    
    // Operator tests
    suite.test("Word operators", test_word_operators);
    
    // String tests
    suite.test("String interpolation", test_string_interpolation);
    
    // Range tests
    suite.test("Range operators", test_range_operators);
    
    // Expression tests
    suite.test("Everything is expression", test_everything_is_expression);
    
    // Collection tests
    suite.test("Collection literals", test_collection_literals);
    
    // Memory tests
    suite.test("Memory keywords", test_memory_keywords);
    
    // Pattern matching tests
    suite.test("Pattern matching", test_pattern_matching);
    
    // Type system tests
    suite.test("Type inference", test_type_inference);
    
    return suite;
}