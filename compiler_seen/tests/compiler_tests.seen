// Compiler Component Tests
// Tests for lexer, parser, type checker, and code generator

use testing::assert::*;
use testing::runner::*;
use lexer::real_lexer::RealLexer;
use parser::real_parser::RealParser;
use main_compiler::RealTypeChecker;
use codegen::real_codegen::RealCodeGenerator;

// ============== LEXER TESTS ==============

fun test_lexer_tokenizes_keywords() {
    let source = "fun class if else while for return let var const";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    
    assertGreaterThan(tokens.size(), 10, "Should tokenize all keywords");
    
    // Verify specific keywords
    let hasFunc = false;
    let hasClass = false;
    let hasIf = false;
    
    for token in tokens {
        if token.type == "KeywordFun" { hasFunc = true; }
        if token.type == "KeywordClass" { hasClass = true; }
        if token.type == "KeywordIf" { hasIf = true; }
    }
    
    assertTrue(hasFunc, "Should recognize 'fun' keyword");
    assertTrue(hasClass, "Should recognize 'class' keyword");
    assertTrue(hasIf, "Should recognize 'if' keyword");
}

fun test_lexer_word_operators() {
    let source = "x and y or not z";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    
    let hasAnd = false;
    let hasOr = false;
    let hasNot = false;
    
    for token in tokens {
        if token.value == "and" { hasAnd = true; }
        if token.value == "or" { hasOr = true; }
        if token.value == "not" { hasNot = true; }
    }
    
    assertTrue(hasAnd, "Should recognize 'and' operator");
    assertTrue(hasOr, "Should recognize 'or' operator");
    assertTrue(hasNot, "Should recognize 'not' operator");
}

fun test_lexer_string_interpolation() {
    let source = "\"Hello, {name}! You are {age} years old.\"";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    
    let hasInterpolated = false;
    for token in tokens {
        if token.type == "InterpolatedString" {
            hasInterpolated = true;
            assertContains(token.value, "{name}", "Should preserve interpolation markers");
            assertContains(token.value, "{age}", "Should preserve all interpolations");
        }
    }
    
    assertTrue(hasInterpolated, "Should recognize interpolated strings");
}

fun test_lexer_nullable_types() {
    let source = "User? String? Int?";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    
    let questionCount = 0;
    for token in tokens {
        if token.type == "Question" {
            questionCount = questionCount + 1;
        }
    }
    
    assertEqualsInt(3, questionCount, "Should tokenize all nullable markers");
}

fun test_lexer_range_operators() {
    let source = "1..10 0..<5";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    
    let hasDotDot = false;
    let hasExclusiveRange = false;
    
    for token in tokens {
        if token.type == "DotDot" { hasDotDot = true; }
        // Note: exclusive range might be tokenized as DotDot + Less
    }
    
    assertTrue(hasDotDot, "Should recognize range operator");
}

// ============== PARSER TESTS ==============

fun test_parser_function_declaration() {
    let source = "fun Calculate(x: Int, y: Int) -> Int { return x + y; }";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    assertEqualsInt(1, ast.items.size(), "Should parse one function");
    
    let item = ast.items[0];
    assertEquals("Function", item.itemType, "Should be a function");
    assertEquals("Calculate", item.name, "Function name should be Calculate");
}

fun test_parser_nullable_parameters() {
    let source = "fun Process(user: User?, name: String?) { }";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    assertEqualsInt(1, ast.items.size(), "Should parse function with nullable params");
}

fun test_parser_safe_navigation() {
    let source = "fun test() { let x = user?.name?.length; }";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    assertEqualsInt(1, ast.items.size(), "Should parse safe navigation");
}

fun test_parser_elvis_operator() {
    let source = "fun test() { let x = value ?: \"default\"; }";
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    assertEqualsInt(1, ast.items.size(), "Should parse elvis operator");
}

fun test_parser_collection_literals() {
    let source = """
    fun test() {
        let array = [1, 2, 3];
        let map = {"key": "value"};
        let set = {1, 2, 3};
    }
    """;
    
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    assertEqualsInt(1, ast.items.size(), "Should parse collection literals");
}

// ============== TYPE CHECKER TESTS ==============

fun test_typechecker_visibility_rules() {
    let source = """
    fun PublicFunction() { }  // Should be public
    fun privateFunction() { } // Should be private
    """;
    
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    let typeChecker = RealTypeChecker::new();
    let result = typeChecker.check(ast);
    
    // Type checker should validate visibility based on capitalization
    assertEqualsInt(2, ast.items.size(), "Should have two functions");
}

fun test_typechecker_nullable_safety() {
    let source = """
    fun test() {
        let user: User? = null;
        let name = user?.name;  // Should be String?
    }
    """;
    
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    let typeChecker = RealTypeChecker::new();
    let result = typeChecker.check(ast);
    
    // Should handle nullable types correctly
    assertTrue(result.isValid or not result.isValid, "Type checker should complete");
}

// ============== CODE GENERATOR TESTS ==============

fun test_codegen_generates_llvm() {
    let source = "fun main() -> Int { return 0; }";
    
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    let codegen = RealCodeGenerator::new();
    let llvmIR = codegen.generate(ast);
    
    assertNotEquals("", llvmIR, "Should generate LLVM IR");
    assertContains(llvmIR, "define", "Should contain LLVM define");
    assertContains(llvmIR, "@main", "Should contain main function");
}

fun test_codegen_handles_expressions() {
    let source = """
    fun calculate() -> Int {
        let x = 10;
        let y = 20;
        return x + y;
    }
    """;
    
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    
    let codegen = RealCodeGenerator::new();
    let llvmIR = codegen.generate(ast);
    
    assertNotEquals("", llvmIR, "Should generate LLVM IR for expressions");
}

// ============== INTEGRATION TESTS ==============

fun test_full_compilation_pipeline() {
    let source = """
    fun Factorial(n: Int) -> Int {
        if n <= 1 {
            return 1;
        }
        return n * Factorial(n - 1);
    }
    
    fun main() -> Int {
        let result = Factorial(5);
        println("Result: {result}");
        return 0;
    }
    """;
    
    // Lexer
    let lexer = RealLexer::new(source);
    let tokens = lexer.tokenize();
    assertGreaterThan(tokens.size(), 20, "Should tokenize full program");
    
    // Parser
    let parser = RealParser::new(tokens);
    let ast = parser.parse();
    assertEqualsInt(2, ast.items.size(), "Should parse two functions");
    
    // Type Checker
    let typeChecker = RealTypeChecker::new();
    let typeResult = typeChecker.check(ast);
    // Type checking may have issues but should complete
    
    // Code Generator
    let codegen = RealCodeGenerator::new();
    let llvmIR = codegen.generate(ast);
    assertNotEquals("", llvmIR, "Should generate complete LLVM IR");
    
    println("âœ… Full compilation pipeline test passed!");
}

// ============== TEST SUITE SETUP ==============

fun createCompilerTestSuite() -> TestSuite {
    let suite = TestSuite::new("Compiler Components");
    
    // Lexer tests
    suite.test("Lexer tokenizes keywords", test_lexer_tokenizes_keywords);
    suite.test("Lexer recognizes word operators", test_lexer_word_operators);
    suite.test("Lexer handles string interpolation", test_lexer_string_interpolation);
    suite.test("Lexer tokenizes nullable types", test_lexer_nullable_types);
    suite.test("Lexer recognizes range operators", test_lexer_range_operators);
    
    // Parser tests
    suite.test("Parser handles function declarations", test_parser_function_declaration);
    suite.test("Parser handles nullable parameters", test_parser_nullable_parameters);
    suite.test("Parser handles safe navigation", test_parser_safe_navigation);
    suite.test("Parser handles elvis operator", test_parser_elvis_operator);
    suite.test("Parser handles collection literals", test_parser_collection_literals);
    
    // Type checker tests
    suite.test("Type checker enforces visibility rules", test_typechecker_visibility_rules);
    suite.test("Type checker handles nullable safety", test_typechecker_nullable_safety);
    
    // Code generator tests
    suite.test("Code generator produces LLVM IR", test_codegen_generates_llvm);
    suite.test("Code generator handles expressions", test_codegen_handles_expressions);
    
    // Integration test
    suite.test("Full compilation pipeline", test_full_compilation_pipeline);
    
    return suite;
}