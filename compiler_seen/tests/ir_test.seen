// Comprehensive IR Generation Tests for Self-Hosting Compiler
// Tests MUST pass before implementing IR generation - TDD approach

import testing.{Test, TestSuite, assert, assertEqual, assertNotEqual, assertThrows}
import ir.{IRGenerator, IRModule, IRFunction, IRInstruction, IRValue, IRType, IRError}
import typechecker.{TypeChecker, TypeInferenceResult}
import parser.{SeenParser, AST}
import lexer.{SeenLexer}

class IRTestSuite extends TestSuite {
    fun new() -> IRTestSuite {
        super("IR Generation Tests")
        registerAllTests()
    }
    
    fun registerAllTests() {
        addTest("test_basic_function_ir")
        addTest("test_variable_declarations")
        addTest("test_arithmetic_expressions")
        addTest("test_control_flow_ir")
        addTest("test_function_calls")
        addTest("test_class_instantiation")
        addTest("test_method_calls")
        addTest("test_memory_management")
        addTest("test_string_operations")
        addTest("test_array_operations")
        addTest("test_nullable_types")
        addTest("test_pattern_matching")
        addTest("test_async_await")
        addTest("test_optimization_hints")
        addTest("test_performance_requirements")
    }
    
    // Test 1: Basic function IR generation
    @Test
    fun test_basic_function_ir() {
        let source = """
        fun main() -> Int {
            return 42
        }
        
        fun add(x: Int, y: Int) -> Int {
            return x + y
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        assertEqual(irModule.errors.length(), 0)
        
        // Check main function
        let mainFunc = irModule.getFunction("main")
        assert(mainFunc != null)
        assertEqual(mainFunc.name, "main")
        assertEqual(mainFunc.returnType.name, "i32")
        assertEqual(mainFunc.parameters.length(), 0)
        
        // Check that it has basic blocks
        assert(mainFunc.blocks.length() > 0)
        let entryBlock = mainFunc.blocks[0]
        assert(entryBlock.instructions.length() > 0)
        
        // Check return instruction
        let lastInstr = entryBlock.instructions[entryBlock.instructions.length() - 1]
        assertEqual(lastInstr.opcode, "ret")
        
        // Check add function
        let addFunc = irModule.getFunction("add")
        assert(addFunc != null)
        assertEqual(addFunc.parameters.length(), 2)
        assertEqual(addFunc.parameters[0].type.name, "i32")
        assertEqual(addFunc.parameters[1].type.name, "i32")
    }
    
    // Test 2: Variable declarations and assignments
    @Test
    fun test_variable_declarations() {
        let source = """
        fun test() {
            let x: Int = 10
            let y = x + 5
            var z: Int = 0
            z = y * 2
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let testFunc = irModule.getFunction("test")
        assert(testFunc != null)
        
        let entryBlock = testFunc.blocks[0]
        let instructions = entryBlock.instructions
        
        // Should have alloca instructions for variables
        let allocaCount = 0
        let storeCount = 0
        let loadCount = 0
        
        for instr in instructions {
            if instr.opcode == "alloca" {
                allocaCount += 1
            } else if instr.opcode == "store" {
                storeCount += 1
            } else if instr.opcode == "load" {
                loadCount += 1
            }
        }
        
        assert(allocaCount >= 3)  // x, y, z
        assert(storeCount >= 3)   // initial assignments
        assert(loadCount >= 2)    // reading x for y calculation, y for z calculation
    }
    
    // Test 3: Arithmetic expressions
    @Test
    fun test_arithmetic_expressions() {
        let source = """
        fun arithmetic() -> Int {
            let a = 10
            let b = 20
            let sum = a + b
            let diff = a - b  
            let prod = a * b
            let quot = a / b
            let rem = a % b
            return sum + diff * prod
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("arithmetic")
        assert(func != null)
        
        let instructions = func.blocks[0].instructions
        
        // Check for arithmetic instructions
        let hasAdd = false
        let hasSub = false
        let hasMul = false
        let hasDiv = false
        let hasRem = false
        
        for instr in instructions {
            if instr.opcode == "add" {
                hasAdd = true
            } else if instr.opcode == "sub" {
                hasSub = true
            } else if instr.opcode == "mul" {
                hasMul = true
            } else if instr.opcode == "sdiv" or instr.opcode == "udiv" {
                hasDiv = true
            } else if instr.opcode == "srem" or instr.opcode == "urem" {
                hasRem = true
            }
        }
        
        assert(hasAdd)
        assert(hasSub)
        assert(hasMul)
        assert(hasDiv)
        assert(hasRem)
    }
    
    // Test 4: Control flow IR generation
    @Test
    fun test_control_flow_ir() {
        let source = """
        fun controlFlow(x: Int) -> Int {
            if x > 0 {
                return x * 2
            } else {
                return x * -1
            }
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("controlFlow")
        assert(func != null)
        
        // Should have multiple basic blocks for if-else
        assert(func.blocks.length() >= 3)  // entry, then, else
        
        let entryBlock = func.blocks[0]
        let lastInstr = entryBlock.instructions[entryBlock.instructions.length() - 1]
        
        // Entry block should end with conditional branch
        assert(lastInstr.opcode == "br")
        
        // Check for comparison instruction
        let hasICmp = false
        for instr in entryBlock.instructions {
            if instr.opcode == "icmp" {
                hasICmp = true
                break
            }
        }
        assert(hasICmp)
    }
    
    // Test 5: Function calls
    @Test
    fun test_function_calls() {
        let source = """
        fun helper(x: Int) -> Int {
            return x + 1
        }
        
        fun caller() -> Int {
            let result = helper(42)
            return helper(result)
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let callerFunc = irModule.getFunction("caller")
        assert(callerFunc != null)
        
        let instructions = callerFunc.blocks[0].instructions
        
        // Should have call instructions
        let callCount = 0
        for instr in instructions {
            if instr.opcode == "call" {
                callCount += 1
            }
        }
        
        assertEqual(callCount, 2)  // Two calls to helper
    }
    
    // Test 6: Class instantiation
    @Test
    fun test_class_instantiation() {
        let source = """
        class Point {
            let x: Int
            let y: Int
            
            fun new(x: Int, y: Int) -> Point {
                this.x = x
                this.y = y
            }
        }
        
        fun createPoint() -> Point {
            return Point.new(10, 20)
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        // Should have constructor function
        let constructor = irModule.getFunction("Point.new")
        assert(constructor != null)
        
        // Should have class type definition
        let pointType = irModule.getType("Point")
        assert(pointType != null)
        assert(pointType.isStruct())
        
        let createFunc = irModule.getFunction("createPoint")
        assert(createFunc != null)
        
        // Should have memory allocation for object
        let instructions = createFunc.blocks[0].instructions
        let hasMalloc = false
        let hasCall = false
        
        for instr in instructions {
            if instr.opcode == "call" {
                if instr.callee.contains("malloc") {
                    hasMalloc = true
                } else if instr.callee.contains("Point.new") {
                    hasCall = true
                }
            }
        }
        
        assert(hasMalloc or hasCall)  // Either direct malloc or constructor call
    }
    
    // Test 7: Method calls
    @Test
    fun test_method_calls() {
        let source = """
        class Calculator {
            fun add(x: Int, y: Int) -> Int {
                return x + y
            }
        }
        
        fun useCalculator() -> Int {
            let calc = Calculator.new()
            return calc.add(5, 3)
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let useFunc = irModule.getFunction("useCalculator")
        assert(useFunc != null)
        
        let instructions = useFunc.blocks[0].instructions
        
        // Should have method call
        let hasMethodCall = false
        for instr in instructions {
            if instr.opcode == "call" and instr.callee.contains("Calculator.add") {
                hasMethodCall = true
                break
            }
        }
        assert(hasMethodCall)
    }
    
    // Test 8: Memory management
    @Test
    fun test_memory_management() {
        let source = """
        fun allocateAndFree() {
            let data = Array<Int>.new(100)
            // data should be automatically freed at end of scope
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("allocateAndFree")
        assert(func != null)
        
        let instructions = func.blocks[0].instructions
        
        // Should have allocation
        let hasMalloc = false
        let hasFree = false
        
        for instr in instructions {
            if instr.opcode == "call" {
                if instr.callee.contains("malloc") {
                    hasMalloc = true
                } else if instr.callee.contains("free") {
                    hasFree = true
                }
            }
        }
        
        assert(hasMalloc)
        // Free might be generated automatically by memory manager
    }
    
    // Test 9: String operations
    @Test
    fun test_string_operations() {
        let source = """
        fun stringTest() -> String {
            let greeting = "Hello"
            let name = "World"
            let result = greeting + ", " + name + "!"
            return result
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("stringTest")
        assert(func != null)
        
        // Should have string constants
        assert(irModule.stringConstants.length() > 0)
        
        // Should have string concatenation calls
        let instructions = func.blocks[0].instructions
        let hasStringCall = false
        
        for instr in instructions {
            if instr.opcode == "call" and 
               (instr.callee.contains("string_concat") or instr.callee.contains("strcat")) {
                hasStringCall = true
                break
            }
        }
        
        assert(hasStringCall)
    }
    
    // Test 10: Array operations
    @Test
    fun test_array_operations() {
        let source = """
        fun arrayTest() -> Int {
            let arr = [1, 2, 3, 4, 5]
            let sum = 0
            for i in 0..arr.length() {
                sum += arr[i]
            }
            return sum
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("arrayTest")
        assert(func != null)
        
        // Should have multiple blocks for loop
        assert(func.blocks.length() >= 3)  // entry, loop, exit
        
        let instructions = func.getAllInstructions()
        
        // Should have getelementptr for array access
        let hasGEP = false
        for instr in instructions {
            if instr.opcode == "getelementptr" {
                hasGEP = true
                break
            }
        }
        assert(hasGEP)
    }
    
    // Test 11: Nullable types
    @Test  
    fun test_nullable_types() {
        let source = """
        fun nullableTest(user: User?) -> String {
            if user != null {
                return user.name
            } else {
                return "Anonymous"
            }
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("nullableTest")
        assert(func != null)
        
        // Should have null checks
        let instructions = func.getAllInstructions()
        let hasNullCheck = false
        
        for instr in instructions {
            if instr.opcode == "icmp" and instr.toString().contains("null") {
                hasNullCheck = true
                break
            }
        }
        assert(hasNullCheck)
    }
    
    // Test 12: Pattern matching
    @Test
    fun test_pattern_matching() {
        let source = """
        fun matchTest(value: Int) -> String {
            match value {
                0 -> "zero"
                1 -> "one"
                2 -> "two"
                _ -> "other"
            }
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("matchTest")
        assert(func != null)
        
        // Should have multiple blocks for match arms
        assert(func.blocks.length() >= 4)  // entry, case0, case1, case2, default
        
        // Should have switch instruction or series of comparisons
        let instructions = func.getAllInstructions()
        let hasSwitch = false
        let hasICmp = false
        
        for instr in instructions {
            if instr.opcode == "switch" {
                hasSwitch = true
            } else if instr.opcode == "icmp" {
                hasICmp = true
            }
        }
        
        assert(hasSwitch or hasICmp)  // Either switch or if-else chain
    }
    
    // Test 13: Async/await (simplified)
    @Test
    fun test_async_await() {
        let source = """
        async fun fetchData() -> String {
            let result = await networkCall()
            return result
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("fetchData")
        assert(func != null)
        
        // Async functions should have special handling
        // For MVP, might generate regular function with runtime calls
        let instructions = func.getAllInstructions()
        let hasAsyncCall = false
        
        for instr in instructions {
            if instr.opcode == "call" and 
               (instr.callee.contains("async") or instr.callee.contains("await")) {
                hasAsyncCall = true
                break
            }
        }
        
        // For MVP implementation, this might just be regular calls
        // assert(hasAsyncCall)
    }
    
    // Test 14: Optimization hints
    @Test
    fun test_optimization_hints() {
        let source = """
        fun optimizedLoop(arr: Array<Int>) -> Int {
            let sum = 0
            for i in 0..arr.length() {
                sum += arr[i]  // Should generate vectorizable code
            }
            return sum
        }
        """
        
        let irModule = generateIR(source)
        assert(irModule.success)
        
        let func = irModule.getFunction("optimizedLoop")
        assert(func != null)
        
        // Check that loop has proper structure for optimization
        assert(func.blocks.length() >= 3)  // preheader, loop, exit
        
        // Loop should have proper phi nodes
        let instructions = func.getAllInstructions()
        let hasPhiNode = false
        
        for instr in instructions {
            if instr.opcode == "phi" {
                hasPhiNode = true
                break
            }
        }
        assert(hasPhiNode)
    }
    
    // Test 15: Performance requirements
    @Test
    fun test_performance_requirements() {
        let source = """
        fun performanceTest() -> Int {
            let result = 0
            for i in 0..1000 {
                result += i * i
            }
            return result
        }
        """
        
        let startTime = getCurrentTime()
        let irModule = generateIR(source)
        let endTime = getCurrentTime()
        let duration = endTime - startTime
        
        assert(irModule.success)
        
        // IR generation should be fast (target: 800K lines/sec)
        // For 1000 iteration loop, should generate < 100 lines of IR
        // Should complete in < 1ms for this small example
        assert(duration < 10)  // 10ms should be plenty for this test
        
        let func = irModule.getFunction("performanceTest")
        assert(func != null)
        assert(func.blocks.length() > 0)
        
        // Verify IR is well-formed
        assert(irModule.verify())
    }
}

// Helper function to generate IR from source
fun generateIR(source: String, language: String = "en") -> IRModule {
    let lexer = SeenLexer.new(source, 1, language)
    let tokens = lexer.tokenize()
    let parser = SeenParser.new(tokens)
    let ast = parser.parse()
    let typeChecker = TypeChecker.new()
    let typeResult = typeChecker.check(ast)
    
    if !typeResult.success {
        return IRModule.newWithErrors(typeResult.errors)
    }
    
    let irGenerator = IRGenerator.new()
    return irGenerator.generate(ast, typeResult)
}

// Export the test suite creation function
export fun createIRTests() -> IRTestSuite {
    return IRTestSuite.new()
}