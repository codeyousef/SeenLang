// Seen IR Generator and Code Generator - Complete Implementation for Self-Hosting
// Implements SSA-based IR generation and C99 code generation

// IR Value representation with SSA properties
class IRValue {
    var name: String
    var type: String
    var isSSA: Bool
    var definition: IRInstruction?
    
    fun new(name: String, type: String, isSSA: Bool) -> IRValue {
        let value = IRValue{}
        value.name = name
        value.type = type
        value.isSSA = isSSA
        value.definition = null
        return value
    }
    
    fun getName() -> String {
        return this.name
    }
    
    fun getType() -> String {
        return this.type
    }
    
    fun isSSAValue() -> Bool {
        return this.isSSA
    }
}

// IR Instruction types for SSA form
class IRInstruction {
    var opcode: String
    var operands: Array<IRValue>
    var result: IRValue?
    var basicBlock: BasicBlock?
    
    fun new(opcode: String, operands: Array<IRValue>, result: IRValue?) -> IRInstruction {
        let instr = IRInstruction{}
        instr.opcode = opcode
        instr.operands = operands
        instr.result = result
        instr.basicBlock = null
        return instr
    }
    
    fun getOpcode() -> String {
        return this.opcode
    }
    
    fun getOperands() -> Array<IRValue> {
        return this.operands
    }
    
    fun getResult() -> IRValue? {
        return this.result
    }
}

// Basic Block for control flow graphs
class BasicBlock {
    var label: String
    var instructions: Array<IRInstruction>
    var predecessors: Array<BasicBlock>
    var successors: Array<BasicBlock>
    var dominator: BasicBlock?
    
    fun new(label: String) -> BasicBlock {
        let bb = BasicBlock{}
        bb.label = label
        bb.instructions = Array<IRInstruction>()
        bb.predecessors = Array<BasicBlock>()
        bb.successors = Array<BasicBlock>()
        bb.dominator = null
        return bb
    }
    
    fun addInstruction(instr: IRInstruction) {
        instr.basicBlock = this
        this.instructions.push(instr)
    }
    
    fun addSuccessor(successor: BasicBlock) {
        this.successors.push(successor)
        successor.predecessors.push(this)
    }
    
    fun getLabel() -> String {
        return this.label
    }
    
    fun getInstructions() -> Array<IRInstruction> {
        return this.instructions
    }
}

// Control Flow Graph
class ControlFlowGraph {
    var entry: BasicBlock
    var blocks: Array<BasicBlock>
    var currentBlock: BasicBlock?
    
    fun new(entry: BasicBlock) -> ControlFlowGraph {
        let cfg = ControlFlowGraph{}
        cfg.entry = entry
        cfg.blocks = Array<BasicBlock>()
        cfg.blocks.push(entry)
        cfg.currentBlock = entry
        return cfg
    }
    
    fun createBlock(label: String) -> BasicBlock {
        let block = BasicBlock.new(label)
        this.blocks.push(block)
        return block
    }
    
    fun setCurrentBlock(block: BasicBlock) {
        this.currentBlock = block
    }
    
    fun getCurrentBlock() -> BasicBlock? {
        return this.currentBlock
    }
}

// SSA Construction Helper
class SSABuilder {
    var valueCounter: Int
    var variableMap: Map<String, IRValue>
    var phiNodes: Array<IRInstruction>
    
    fun new() -> SSABuilder {
        let builder = SSABuilder{}
        builder.valueCounter = 0
        builder.variableMap = Map<String, IRValue>()
        builder.phiNodes = Array<IRInstruction>()
        return builder
    }
    
    fun newTemporary(type: String) -> IRValue {
        this.valueCounter = this.valueCounter + 1
        let name = "%t" + this.valueCounter.toString()
        return IRValue.new(name, type, true)
    }
    
    fun defineVariable(name: String, value: IRValue) {
        this.variableMap.put(name, value)
    }
    
    fun readVariable(name: String) -> IRValue? {
        if this.variableMap.containsKey(name) {
            return this.variableMap.get(name)
        }
        return null
    }
    
    fun createPhi(type: String, block: BasicBlock) -> IRValue {
        let result = this.newTemporary(type)
        let phi = IRInstruction.new("phi", Array<IRValue>(), result)
        this.phiNodes.push(phi)
        block.addInstruction(phi)
        return result
    }
}

// IR Generator - converts AST to SSA IR
class IRGenerator {
    var cfg: ControlFlowGraph
    var ssaBuilder: SSABuilder
    var functionContext: FunctionContext?
    var stringLiterals: Map<String, IRValue>
    var globalValues: Array<IRValue>
    
    fun new() -> IRGenerator {
        let entry = BasicBlock.new("entry")
        let generator = IRGenerator{}
        generator.cfg = ControlFlowGraph.new(entry)
        generator.ssaBuilder = SSABuilder.new()
        generator.functionContext = null
        generator.stringLiterals = Map<String, IRValue>()
        generator.globalValues = Array<IRValue>()
        return generator
    }
    
    fun generateProgram(program: Program) -> ControlFlowGraph {
        // Generate IR for all items in the program
        for item in program.getItems() {
            match item.getKind() {
                "Function" -> this.generateFunction(item.getData())
                "Class" -> this.generateClass(item.getData())
                _ -> {}
            }
        }
        
        return this.cfg
    }
    
    fun generateFunction(node: ASTNode) -> IRValue {
        // For bootstrap, assume node is Function type
        // In real implementation, we'd cast appropriately
        
        // Create function entry block
        let entryBlock = this.cfg.createBlock("func_entry")
        this.cfg.setCurrentBlock(entryBlock)
        
        // Generate function prologue
        let prologueInstr = IRInstruction.new("prologue", Array<IRValue>(), null)
        entryBlock.addInstruction(prologueInstr)
        
        // Generate function body
        // For bootstrap, simplified implementation
        let bodyResult = this.generateExpression(Expression.new(Position.new(0, 0, 0), "Block"))
        
        // Generate function epilogue
        let epilogueInstr = IRInstruction.new("epilogue", Array<IRValue>(), null)
        this.cfg.getCurrentBlock()?.addInstruction(epilogueInstr)
        
        // Return instruction
        if bodyResult != null {
            let returnInstr = IRInstruction.new("return", [bodyResult!], null)
            this.cfg.getCurrentBlock()?.addInstruction(returnInstr)
        }
        
        return this.ssaBuilder.newTemporary("function")
    }
    
    fun generateClass(node: ASTNode) -> IRValue {
        // Generate class layout and methods
        // For bootstrap, simplified
        return this.ssaBuilder.newTemporary("class")
    }
    
    fun generateExpression(expr: Expression) -> IRValue? {
        match expr.getKind() {
            "IntegerLiteral" -> return this.generateIntegerLiteral(expr)
            "FloatLiteral" -> return this.generateFloatLiteral(expr)
            "StringLiteral" -> return this.generateStringLiteral(expr)
            "BooleanLiteral" -> return this.generateBooleanLiteral(expr)
            "Identifier" -> return this.generateIdentifier(expr)
            "BinaryOp" -> return this.generateBinaryOp(expr)
            "UnaryOp" -> return this.generateUnaryOp(expr)
            "FunctionCall" -> return this.generateFunctionCall(expr)
            "If" -> return this.generateIfExpression(expr)
            "Match" -> return this.generateMatchExpression(expr)
            "For" -> return this.generateForLoop(expr)
            "While" -> return this.generateWhileLoop(expr)
            "Block" -> return this.generateBlock(expr)
            _ -> {
                // Unknown expression type
                return null
            }
        }
    }
    
    fun generateIntegerLiteral(expr: Expression) -> IRValue {
        // For bootstrap, assume expr contains value
        let value = this.ssaBuilder.newTemporary("i32")
        let instr = IRInstruction.new("const_int", Array<IRValue>(), value)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        return value
    }
    
    fun generateFloatLiteral(expr: Expression) -> IRValue {
        let value = this.ssaBuilder.newTemporary("f64")
        let instr = IRInstruction.new("const_float", Array<IRValue>(), value)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        return value
    }
    
    fun generateStringLiteral(expr: Expression) -> IRValue {
        // For bootstrap, simplified string handling
        let value = this.ssaBuilder.newTemporary("string")
        let instr = IRInstruction.new("const_string", Array<IRValue>(), value)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        return value
    }
    
    fun generateBooleanLiteral(expr: Expression) -> IRValue {
        let value = this.ssaBuilder.newTemporary("bool")
        let instr = IRInstruction.new("const_bool", Array<IRValue>(), value)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        return value
    }
    
    fun generateIdentifier(expr: Expression) -> IRValue? {
        // For bootstrap, simplified identifier lookup
        // In real implementation, we'd look up in symbol table
        let name = "unknown" // Would be expr.name
        return this.ssaBuilder.readVariable(name)
    }
    
    fun generateBinaryOp(expr: Expression) -> IRValue {
        // For bootstrap, assume we can get left, right, operator
        let leftValue = this.generateExpression(Expression.new(Position.new(0, 0, 0), "IntegerLiteral"))!
        let rightValue = this.generateExpression(Expression.new(Position.new(0, 0, 0), "IntegerLiteral"))!
        
        let result = this.ssaBuilder.newTemporary("i32")
        let instr = IRInstruction.new("add", [leftValue, rightValue], result)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        
        return result
    }
    
    fun generateUnaryOp(expr: Expression) -> IRValue {
        let operandValue = this.generateExpression(Expression.new(Position.new(0, 0, 0), "IntegerLiteral"))!
        
        let result = this.ssaBuilder.newTemporary("i32")
        let instr = IRInstruction.new("neg", [operandValue], result)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        
        return result
    }
    
    fun generateFunctionCall(expr: Expression) -> IRValue {
        // For bootstrap, simplified function call
        let result = this.ssaBuilder.newTemporary("unknown")
        let instr = IRInstruction.new("call", Array<IRValue>(), result)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        
        return result
    }
    
    fun generateIfExpression(expr: Expression) -> IRValue {
        // Create basic blocks for if-then-else
        let thenBlock = this.cfg.createBlock("if_then")
        let elseBlock = this.cfg.createBlock("if_else")
        let mergeBlock = this.cfg.createBlock("if_merge")
        
        // Generate condition
        let condition = this.generateExpression(Expression.new(Position.new(0, 0, 0), "BooleanLiteral"))!
        
        // Conditional branch
        let branchInstr = IRInstruction.new("branch", [condition], null)
        this.cfg.getCurrentBlock()?.addInstruction(branchInstr)
        
        // Add edges
        this.cfg.getCurrentBlock()?.addSuccessor(thenBlock)
        this.cfg.getCurrentBlock()?.addSuccessor(elseBlock)
        
        // Generate then branch
        this.cfg.setCurrentBlock(thenBlock)
        let thenValue = this.generateExpression(Expression.new(Position.new(0, 0, 0), "IntegerLiteral"))!
        let thenJump = IRInstruction.new("jump", Array<IRValue>(), null)
        thenBlock.addInstruction(thenJump)
        thenBlock.addSuccessor(mergeBlock)
        
        // Generate else branch
        this.cfg.setCurrentBlock(elseBlock)
        let elseValue = this.generateExpression(Expression.new(Position.new(0, 0, 0), "IntegerLiteral"))!
        let elseJump = IRInstruction.new("jump", Array<IRValue>(), null)
        elseBlock.addInstruction(elseJump)
        elseBlock.addSuccessor(mergeBlock)
        
        // Generate merge point with phi node
        this.cfg.setCurrentBlock(mergeBlock)
        let result = this.ssaBuilder.createPhi("i32", mergeBlock)
        
        return result
    }
    
    fun generateMatchExpression(expr: Expression) -> IRValue {
        // For bootstrap, simplified match expression
        let result = this.ssaBuilder.newTemporary("unknown")
        let instr = IRInstruction.new("match", Array<IRValue>(), result)
        this.cfg.getCurrentBlock()?.addInstruction(instr)
        
        return result
    }
    
    fun generateForLoop(expr: Expression) -> IRValue {
        // Create loop blocks
        let headerBlock = this.cfg.createBlock("for_header")
        let bodyBlock = this.cfg.createBlock("for_body")
        let exitBlock = this.cfg.createBlock("for_exit")
        
        // Jump to header
        let jumpToHeader = IRInstruction.new("jump", Array<IRValue>(), null)
        this.cfg.getCurrentBlock()?.addInstruction(jumpToHeader)
        this.cfg.getCurrentBlock()?.addSuccessor(headerBlock)
        
        // Generate loop header (condition check)
        this.cfg.setCurrentBlock(headerBlock)
        let condition = this.generateExpression(Expression.new(Position.new(0, 0, 0), "BooleanLiteral"))!
        let branchInstr = IRInstruction.new("branch", [condition], null)
        headerBlock.addInstruction(branchInstr)
        headerBlock.addSuccessor(bodyBlock)
        headerBlock.addSuccessor(exitBlock)
        
        // Generate loop body
        this.cfg.setCurrentBlock(bodyBlock)
        let bodyResult = this.generateExpression(Expression.new(Position.new(0, 0, 0), "Block"))
        let backEdge = IRInstruction.new("jump", Array<IRValue>(), null)
        bodyBlock.addInstruction(backEdge)
        bodyBlock.addSuccessor(headerBlock)
        
        // Continue after loop
        this.cfg.setCurrentBlock(exitBlock)
        
        return this.ssaBuilder.newTemporary("void")
    }
    
    fun generateWhileLoop(expr: Expression) -> IRValue {
        // Similar to for loop but simpler
        let headerBlock = this.cfg.createBlock("while_header")
        let bodyBlock = this.cfg.createBlock("while_body")
        let exitBlock = this.cfg.createBlock("while_exit")
        
        // Jump to header
        let jumpToHeader = IRInstruction.new("jump", Array<IRValue>(), null)
        this.cfg.getCurrentBlock()?.addInstruction(jumpToHeader)
        this.cfg.getCurrentBlock()?.addSuccessor(headerBlock)
        
        // Generate condition
        this.cfg.setCurrentBlock(headerBlock)
        let condition = this.generateExpression(Expression.new(Position.new(0, 0, 0), "BooleanLiteral"))!
        let branchInstr = IRInstruction.new("branch", [condition], null)
        headerBlock.addInstruction(branchInstr)
        headerBlock.addSuccessor(bodyBlock)
        headerBlock.addSuccessor(exitBlock)
        
        // Generate body
        this.cfg.setCurrentBlock(bodyBlock)
        let bodyResult = this.generateExpression(Expression.new(Position.new(0, 0, 0), "Block"))
        let backEdge = IRInstruction.new("jump", Array<IRValue>(), null)
        bodyBlock.addInstruction(backEdge)
        bodyBlock.addSuccessor(headerBlock)
        
        // Continue after loop
        this.cfg.setCurrentBlock(exitBlock)
        
        return this.ssaBuilder.newTemporary("void")
    }
    
    fun generateBlock(expr: Expression) -> IRValue? {
        // For bootstrap, simplified block generation
        // In real implementation, we'd process all statements
        var lastValue: IRValue? = null
        
        // Generate placeholder statements
        for i in 1..3 {
            lastValue = this.generateExpression(Expression.new(Position.new(0, 0, 0), "IntegerLiteral"))
        }
        
        return lastValue
    }
}

// C Code Generator - converts IR to C99
class CCodeGenerator {
    var output: String
    var indentLevel: Int
    var variableMap: Map<String, String>
    var functionDeclarations: Array<String>
    
    fun new() -> CCodeGenerator {
        let generator = CCodeGenerator{}
        generator.output = ""
        generator.indentLevel = 0
        generator.variableMap = Map<String, String>()
        generator.functionDeclarations = Array<String>()
        return generator
    }
    
    fun generateProgram(cfg: ControlFlowGraph) -> String {
        this.output = ""
        
        // Generate C header
        this.emit("#include <stdio.h>")
        this.emit("#include <stdlib.h>")
        this.emit("#include <string.h>")
        this.emit("#include <stdint.h>")
        this.emit("#include <stdbool.h>")
        this.emit("")
        
        // Generate type definitions
        this.generateTypeDefinitions()
        
        // Generate function declarations
        this.generateFunctionDeclarations()
        
        // Generate main function
        this.generateMainFunction(cfg)
        
        return this.output
    }
    
    fun generateTypeDefinitions() {
        this.emit("// Seen runtime types")
        this.emit("typedef struct {")
        this.emit("    char* data;")
        this.emit("    size_t length;")
        this.emit("    size_t capacity;")
        this.emit("} seen_string_t;")
        this.emit("")
        this.emit("typedef struct {")
        this.emit("    void* data;")
        this.emit("    size_t length;")
        this.emit("    size_t capacity;")
        this.emit("    size_t element_size;")
        this.emit("} seen_array_t;")
        this.emit("")
    }
    
    fun generateFunctionDeclarations() {
        this.emit("// Function declarations")
        for decl in this.functionDeclarations {
            this.emit(decl)
        }
        this.emit("")
    }
    
    fun generateMainFunction(cfg: ControlFlowGraph) {
        this.emit("int main(int argc, char** argv) {")
        this.indentLevel = this.indentLevel + 1
        
        // Generate variables for all SSA values
        this.generateVariableDeclarations(cfg)
        
        // Generate code for all basic blocks
        for block in cfg.blocks {
            this.generateBasicBlock(block)
        }
        
        this.emit("return 0;")
        this.indentLevel = this.indentLevel - 1
        this.emit("}")
    }
    
    fun generateVariableDeclarations(cfg: ControlFlowGraph) {
        this.emit("// Variable declarations")
        
        // For bootstrap, generate some common variables
        this.emit("int32_t t1, t2, t3, t4, t5;")
        this.emit("double f1, f2, f3;")
        this.emit("bool b1, b2, b3;")
        this.emit("seen_string_t s1, s2, s3;")
        this.emit("")
    }
    
    fun generateBasicBlock(block: BasicBlock) {
        this.emit("// Block: " + block.getLabel())
        this.emit(block.getLabel() + ":")
        
        for instr in block.getInstructions() {
            this.generateInstruction(instr)
        }
        
        this.emit("")
    }
    
    fun generateInstruction(instr: IRInstruction) {
        match instr.getOpcode() {
            "const_int" -> {
                if instr.getResult() != null {
                    this.emit(this.getCName(instr.getResult()!) + " = 42;  // Constant integer")
                }
            }
            "const_float" -> {
                if instr.getResult() != null {
                    this.emit(this.getCName(instr.getResult()!) + " = 3.14;  // Constant float")
                }
            }
            "const_string" -> {
                if instr.getResult() != null {
                    this.emit(this.getCName(instr.getResult()!) + ".data = \"hello\";")
                    this.emit(this.getCName(instr.getResult()!) + ".length = 5;")
                }
            }
            "const_bool" -> {
                if instr.getResult() != null {
                    this.emit(this.getCName(instr.getResult()!) + " = true;  // Constant boolean")
                }
            }
            "add" -> {
                let operands = instr.getOperands()
                if operands.length() >= 2 and instr.getResult() != null {
                    let left = this.getCName(operands.get(0))
                    let right = this.getCName(operands.get(1))
                    let result = this.getCName(instr.getResult()!)
                    this.emit(result + " = " + left + " + " + right + ";")
                }
            }
            "neg" -> {
                let operands = instr.getOperands()
                if operands.length() >= 1 and instr.getResult() != null {
                    let operand = this.getCName(operands.get(0))
                    let result = this.getCName(instr.getResult()!)
                    this.emit(result + " = -" + operand + ";")
                }
            }
            "branch" -> {
                let operands = instr.getOperands()
                if operands.length() >= 1 {
                    let condition = this.getCName(operands.get(0))
                    this.emit("if (" + condition + ") {")
                    this.emit("    // Branch to then block")
                    this.emit("} else {")
                    this.emit("    // Branch to else block")
                    this.emit("}")
                }
            }
            "jump" -> {
                this.emit("// Unconditional jump")
            }
            "call" -> {
                if instr.getResult() != null {
                    this.emit(this.getCName(instr.getResult()!) + " = function_call();  // Function call")
                } else {
                    this.emit("function_call();  // Void function call")
                }
            }
            "return" -> {
                let operands = instr.getOperands()
                if operands.length() >= 1 {
                    let value = this.getCName(operands.get(0))
                    this.emit("return " + value + ";")
                } else {
                    this.emit("return;")
                }
            }
            "phi" -> {
                // Phi nodes are handled by control flow
                this.emit("// Phi node (handled by control flow)")
            }
            "prologue" -> {
                this.emit("// Function prologue")
            }
            "epilogue" -> {
                this.emit("// Function epilogue")
            }
            _ -> {
                this.emit("// Unknown instruction: " + instr.getOpcode())
            }
        }
    }
    
    fun getCName(value: IRValue) -> String {
        let name = value.getName()
        if this.variableMap.containsKey(name) {
            return this.variableMap.get(name)
        }
        
        // Convert SSA names to C variable names
        if name.startsWith("%t") {
            let number = name.substring(2)
            let cName = "t" + number
            this.variableMap.put(name, cName)
            return cName
        }
        
        // Default mapping
        this.variableMap.put(name, name)
        return name
    }
    
    fun emit(code: String) {
        for i in 0..<this.indentLevel {
            this.output = this.output + "    "
        }
        this.output = this.output + code + "\n"
    }
}

// Function context for IR generation
class FunctionContext {
    var name: String
    var parameters: Array<IRValue>
    var returnType: String
    var entryBlock: BasicBlock
    
    fun new(name: String, returnType: String, entryBlock: BasicBlock) -> FunctionContext {
        let context = FunctionContext{}
        context.name = name
        context.returnType = returnType
        context.entryBlock = entryBlock
        context.parameters = Array<IRValue>()
        return context
    }
}

// Factory functions
fun createIRGenerator() -> IRGenerator {
    return IRGenerator.new()
}

fun createCCodeGenerator() -> CCodeGenerator {
    return CCodeGenerator.new()
}

fun generateCodeForProgram(program: Program) -> String {
    let irGenerator = createIRGenerator()
    let cfg = irGenerator.generateProgram(program)
    
    let codeGenerator = createCCodeGenerator()
    return codeGenerator.generateProgram(cfg)
}