// Abstract Syntax Tree definitions for the Seen language
// Ported from Rust implementation with all Kotlin-inspired features

import std.collections.Vec;
import lexer.TokenType;

// Root program node
struct Program {
    items: Vec<Item>,
}

// Top-level item (function, struct, enum, etc.)
struct Item {
    visibility: Visibility,
    kind: ItemKind,
}

// Visibility modifiers
enum Visibility {
    Public,
    Private,
    Protected,  // For inheritance
}

// Different kinds of top-level items
enum ItemKind {
    Function(Function),
    Struct(Struct),
    Enum(Enum),
    Trait(Trait),
    Impl(Impl),
    DataClass(DataClass),
    SealedClass(SealedClass),
    Interface(Interface),
    Object(Object),
    Import(Import),
    Export(Export),
    Const(Const),
    Static(Static),
}

// Function declaration
struct Function {
    name: str,
    type_params: Vec<TypeParameter>,
    params: Vec<Parameter>,
    return_type: Option<Type>,
    body: Option<Block>,
    modifiers: Vec<TokenType>,  // inline, infix, operator, suspend, etc.
    where_clause: Option<WhereClause>,
}

// Function parameter
struct Parameter {
    name: str,
    param_type: Type,
    default_value: Option<Expression>,
    is_vararg: bool,
}

// Generic type parameter
struct TypeParameter {
    name: str,
    bounds: Vec<Type>,
    variance: Variance,  // in, out, invariant
}

// Variance for generic type parameters
enum Variance {
    Invariant,
    Covariant,      // out
    Contravariant,  // in
}

// Where clause for generic constraints
struct WhereClause {
    constraints: Vec<WhereConstraint>,
}

// Individual constraint in where clause
struct WhereConstraint {
    type_param: str,
    bounds: Vec<Type>,
}

// Struct declaration
struct Struct {
    name: str,
    type_params: Vec<TypeParameter>,
    fields: Vec<Field>,
    parents: Vec<Type>,  // Inheritance and trait implementations
}

// Struct field
struct Field {
    name: str,
    field_type: Type,
    visibility: Visibility,
}

// Data class (Kotlin-inspired)
struct DataClass {
    name: str,
    type_params: Vec<TypeParameter>,
    params: Vec<DataClassParameter>,
    body: Option<Vec<Item>>,  // Additional methods
}

// Data class parameter (becomes both parameter and field)
struct DataClassParameter {
    name: str,
    param_type: Type,
    visibility: Visibility,
    is_var: bool,  // var vs val
    default_value: Option<Expression>,
}

// Sealed class (Kotlin-inspired)
struct SealedClass {
    name: str,
    type_params: Vec<TypeParameter>,
    variants: Vec<Variant>,
}

// Sealed class variant
struct Variant {
    name: str,
    params: Option<Vec<Parameter>>,
}

// Enum declaration
struct Enum {
    name: str,
    type_params: Vec<TypeParameter>,
    variants: Vec<EnumVariant>,
}

// Enum variant
struct EnumVariant {
    name: str,
    fields: Option<Vec<Field>>,
    discriminant: Option<Expression>,
}

// Trait declaration
struct Trait {
    name: str,
    type_params: Vec<TypeParameter>,
    supertraits: Vec<Type>,
    items: Vec<TraitItem>,
}

// Item within a trait
enum TraitItem {
    Function(TraitFunction),
    Type(AssociatedType),
    Const(TraitConst),
}

// Function declaration in trait
struct TraitFunction {
    name: str,
    type_params: Vec<TypeParameter>,
    params: Vec<Parameter>,
    return_type: Option<Type>,
    default_impl: Option<Block>,
}

// Associated type in trait
struct AssociatedType {
    name: str,
    bounds: Vec<Type>,
    default: Option<Type>,
}

// Const declaration in trait
struct TraitConst {
    name: str,
    const_type: Type,
    default: Option<Expression>,
}

// Implementation block
struct Impl {
    trait_ref: Option<Type>,  // None for inherent impl
    type_ref: Type,
    type_params: Vec<TypeParameter>,
    items: Vec<ImplItem>,
    where_clause: Option<WhereClause>,
}

// Item within an impl block
enum ImplItem {
    Function(Function),
    Type(TypeAlias),
    Const(Const),
}

// Interface (similar to trait but with multiple inheritance)
struct Interface {
    name: str,
    type_params: Vec<TypeParameter>,
    parents: Vec<Type>,
    items: Vec<TraitItem>,
}

// Object declaration (singleton)
struct Object {
    name: str,
    parents: Vec<Type>,
    items: Vec<Item>,
}

// Import declaration
struct Import {
    path: ImportPath,
    alias: Option<str>,
    items: Option<Vec<ImportItem>>,
}

// Import path
enum ImportPath {
    Simple(str),
    Compound(Vec<str>),
    Glob(Vec<str>),  // import foo.bar.*;
}

// Individual import item
struct ImportItem {
    name: str,
    alias: Option<str>,
}

// Export declaration
struct Export {
    item: Box<Item>,
    alias: Option<str>,
}

// Constant declaration
struct Const {
    name: str,
    const_type: Option<Type>,
    value: Expression,
}

// Static declaration
struct Static {
    name: str,
    static_type: Option<Type>,
    value: Expression,
    is_mutable: bool,
}

// Type alias
struct TypeAlias {
    name: str,
    type_params: Vec<TypeParameter>,
    aliased_type: Type,
}

// Type representations
enum Type {
    Unknown,
    Unit,                                // ()
    Bool,
    Int(IntType),
    Float(FloatType),
    Char,
    String,
    Array(Box<Type>, Option<i32>),      // [T; N] or [T]
    Tuple(Vec<Type>),                   // (T1, T2, ...)
    Function(Vec<Type>, Box<Type>),     // (T1, T2) -> R
    Named(str, Vec<Type>),              // MyType<T1, T2>
    Generic(str),                       // T
    Reference(Box<Type>, bool),         // &T or &mut T
    Optional(Box<Type>),                // T?
    Result(Box<Type>, Box<Type>),       // Result<T, E>
    Range(Box<Type>),                   // Range<T>
    Observable(Box<Type>),              // Observable<T>
    Flow(Box<Type>),                    // Flow<T>
}

// Integer types
enum IntType {
    I8, I16, I32, I64, I128,
    U8, U16, U32, U64, U128,
    ISize, USize,
}

// Float types
enum FloatType {
    F32, F64,
}

// Statements
enum Statement {
    Expression { expr: Expression },
    Let { 
        name: str, 
        var_type: Option<Type>, 
        value: Option<Expression>, 
        is_mutable: bool 
    },
    Return { value: Option<Expression> },
    Break { label: Option<str> },
    Continue { label: Option<str> },
    While { condition: Expression, body: Block },
    For { 
        variable: str, 
        iterable: Expression, 
        body: Block 
    },
    Block(Block),
}

// Block of statements
struct Block {
    statements: Vec<Statement>,
}

// Expressions
enum Expression {
    Literal { value: LiteralValue },
    Identifier { name: str },
    Binary { 
        left: Box<Expression>, 
        operator: TokenType, 
        right: Box<Expression> 
    },
    Unary { 
        operator: TokenType, 
        operand: Box<Expression> 
    },
    Call { 
        callee: Box<Expression>, 
        args: Vec<Expression> 
    },
    Member { 
        object: Box<Expression>, 
        member: str 
    },
    Index { 
        object: Box<Expression>, 
        index: Box<Expression> 
    },
    Assignment { 
        target: Box<Expression>, 
        operator: TokenType, 
        value: Box<Expression> 
    },
    If { 
        condition: Box<Expression>, 
        then_branch: Box<Expression>, 
        else_branch: Option<Box<Expression>> 
    },
    Match { 
        expr: Box<Expression>, 
        arms: Vec<MatchArm> 
    },
    Block(Block),
    Array { elements: Vec<Expression> },
    Tuple { elements: Vec<Expression> },
    Struct { 
        name: str, 
        fields: Vec<FieldInit> 
    },
    Lambda { 
        params: Vec<Parameter>, 
        body: Box<Expression>,
        is_async: bool,
        is_suspend: bool,
    },
    Range { 
        start: Option<Box<Expression>>, 
        end: Option<Box<Expression>>, 
        inclusive: bool 
    },
    Try { 
        expr: Box<Expression>, 
        catch_clauses: Vec<CatchClause>, 
        finally_clause: Option<Block> 
    },
    Throw { expr: Box<Expression> },
    
    // Kotlin-inspired expressions
    SafeCall { 
        object: Box<Expression>, 
        member: str 
    },
    Elvis { 
        left: Box<Expression>, 
        right: Box<Expression> 
    },
    NotNull { expr: Box<Expression> },
    
    // Reactive programming expressions
    Observable { 
        items: Vec<Expression> 
    },
    Flow { 
        generator: Box<Expression> 
    },
    Subscribe { 
        observable: Box<Expression>, 
        observer: Box<Expression> 
    },
    Emit { 
        value: Box<Expression> 
    },
    Collect { 
        flow: Box<Expression>, 
        collector: Box<Expression> 
    },
    
    // Pattern matching and destructuring
    Destructure { 
        pattern: Pattern, 
        value: Box<Expression> 
    },
}

// Literal values
enum LiteralValue {
    Boolean(bool),
    Integer(i64),
    Float(f64),
    String(str),
    Char(char),
    Null,
    Undefined,
}

// Match arm
struct MatchArm {
    pattern: Pattern,
    guard: Option<Expression>,
    body: Expression,
}

// Patterns for pattern matching
enum Pattern {
    Wildcard,                           // _
    Identifier(str),                    // x
    Literal(LiteralValue),              // 42, "hello"
    Tuple(Vec<Pattern>),                // (x, y, z)
    Array(Vec<Pattern>),                // [x, y, z]
    Struct(str, Vec<FieldPattern>),     // Point { x, y }
    Enum(str, Vec<Pattern>),            // Some(x)
    Range(LiteralValue, LiteralValue),  // 1..10
    Guard(Box<Pattern>, Expression),    // x if x > 0
    Or(Vec<Pattern>),                   // x | y | z
    Reference(Box<Pattern>),            // &x
}

// Field pattern in struct pattern
struct FieldPattern {
    name: str,
    pattern: Pattern,
}

// Field initialization in struct expression
struct FieldInit {
    name: str,
    value: Expression,
}

// Try-catch clause
struct CatchClause {
    exception_type: Option<Type>,
    variable: Option<str>,
    body: Block,
}

// Operator precedence levels (for parser)
enum Precedence {
    None,
    Assignment,     // =
    Or,             // ||  
    And,            // &&
    Equality,       // == !=
    Comparison,     // < > <= >=
    Term,           // + -
    Factor,         // * / %
    Unary,          // ! -
    Call,           // . () []
    Primary,
}

// Additional utility functions for AST
impl Expression {
    // Check if expression is a literal
    fun is_literal(self) -> bool {
        match self {
            Expression::Literal { .. } => true,
            _ => false,
        }
    }
    
    // Check if expression is an identifier
    fun is_identifier(self) -> bool {
        match self {
            Expression::Identifier { .. } => true,
            _ => false,
        }
    }
    
    // Check if expression is assignable (can be on left side of assignment)
    fun is_assignable(self) -> bool {
        match self {
            Expression::Identifier { .. } | 
            Expression::Member { .. } | 
            Expression::Index { .. } => true,
            _ => false,
        }
    }
}

impl Type {
    // Check if type is primitive
    fun is_primitive(self) -> bool {
        match self {
            Type::Bool | Type::Int(_) | Type::Float(_) | 
            Type::Char | Type::String => true,
            _ => false,
        }
    }
    
    // Check if type is generic
    fun is_generic(self) -> bool {
        match self {
            Type::Generic(_) => true,
            Type::Named(_, params) => !params.is_empty(),
            _ => false,
        }
    }
    
    // Check if type is nullable
    fun is_nullable(self) -> bool {
        match self {
            Type::Optional(_) => true,
            _ => false,
        }
    }
    
    // Get the base type (unwrap Optional, Reference, etc.)
    fun base_type(self) -> Type {
        match self {
            Type::Optional(inner) | Type::Reference(inner, _) => inner.base_type(),
            _ => self,
        }
    }
}

impl Program {
    // Create empty program
    fun new() -> Self {
        Self { items: Vec::new() }
    }
    
    // Add item to program
    fun add_item(mut self, item: Item) {
        self.items.push(item);
    }
    
    // Find function by name
    fun find_function(self, name: str) -> Option<&Function> {
        for item in &self.items {
            if let ItemKind::Function(ref func) = item.kind {
                if func.name == name {
                    return Some(func);
                }
            }
        }
        None
    }
    
    // Get all public items
    fun public_items(self) -> Vec<&Item> {
        self.items.iter()
            .filter(|item| matches!(item.visibility, Visibility::Public))
            .collect()
    }
}