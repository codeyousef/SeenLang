// Self-hosted Seen Parser
// Ported from Rust implementation with all Kotlin-inspired features
// Target: >800K lines/sec (allowing overhead for self-hosting)

import std.collections.Vec;
import std.core.Result;
import std.core.Option;
import lexer.Token;
import lexer.TokenType;
import "ast.seen";

// Main parser structure
struct SeenParser {
    tokens: Vec<Token>,
    current: i32,
    had_error: bool,
}

impl SeenParser {
    // Create new parser instance
    fun new() -> Self {
        Self {
            tokens: Vec::new(),
            current: 0,
            had_error: false,
        }
    }
    
    // Parse tokens into AST
    fun parse_tokens(mut self, tokens: Vec<Token>) -> Result<Program, str> {
        self.tokens = tokens;
        self.current = 0;
        self.had_error = false;
        
        self.parse_program()
    }
    
    // Parse complete program (top-level items)
    fun parse_program(mut self) -> Result<Program, str> {
        let mut items = Vec::new();
        
        while !self.is_at_end() {
            match self.parse_top_level_item() {
                Ok(item) => items.push(item),
                Err(error) => {
                    self.had_error = true;
                    // Try to recover by synchronizing to next statement
                    self.synchronize();
                    return Err(error);
                }
            }
        }
        
        if self.had_error {
            Err("Parse errors occurred".to_string())
        } else {
            Ok(Program { items })
        }
    }
    
    // Parse top-level item (function, struct, enum, etc.)
    fun parse_top_level_item(mut self) -> Result<Item, str> {
        // Handle visibility modifiers
        let visibility = if self.match_token(TokenType::KeywordPub) {
            Visibility::Public
        } else {
            Visibility::Private
        };
        
        match self.peek().token_type {
            TokenType::KeywordFun => self.parse_function(visibility),
            TokenType::KeywordStruct => self.parse_struct(visibility),
            TokenType::KeywordEnum => self.parse_enum(visibility),
            TokenType::KeywordTrait => self.parse_trait(visibility),
            TokenType::KeywordImpl => self.parse_impl(visibility),
            TokenType::KeywordData => self.parse_data_class(visibility),
            TokenType::KeywordSealed => self.parse_sealed_class(visibility),
            TokenType::KeywordInterface => self.parse_interface(visibility),
            TokenType::KeywordObject => self.parse_object(visibility),
            TokenType::KeywordImport => self.parse_import(),
            TokenType::KeywordExport => self.parse_export(),
            TokenType::KeywordConst => self.parse_const(visibility),
            TokenType::KeywordStatic => self.parse_static(visibility),
            _ => Err(format!("Unexpected token in top-level context: {}", self.peek().lexeme)),
        }
    }
    
    // Parse function declaration
    fun parse_function(mut self, visibility: Visibility) -> Result<Item, str> {
        self.consume(TokenType::KeywordFun, "Expected 'fun'")?;
        
        // Function modifiers
        let mut modifiers = Vec::new();
        
        // Check for inline, infix, operator, suspend, etc.
        while self.match_any(&[
            TokenType::KeywordInline,
            TokenType::KeywordInfix,
            TokenType::KeywordOperator,
            TokenType::KeywordSuspend,
            TokenType::KeywordOverride,
        ]) {
            modifiers.push(self.previous().token_type.clone());
        }
        
        // Function name
        let name = self.consume(TokenType::Identifier, "Expected function name")?.lexeme.to_string();
        
        // Generic type parameters
        let type_params = if self.match_token(TokenType::Less) {
            self.parse_type_parameters()?
        } else {
            Vec::new()
        };
        
        // Parameters
        self.consume(TokenType::LeftParen, "Expected '(' after function name")?;
        let params = self.parse_parameter_list()?;
        self.consume(TokenType::RightParen, "Expected ')' after parameters")?;
        
        // Return type
        let return_type = if self.match_token(TokenType::Arrow) {
            Some(self.parse_type()?)
        } else {
            None
        };
        
        // Where clause for generic constraints
        let where_clause = if self.match_token(TokenType::KeywordWhere) {
            Some(self.parse_where_clause()?)
        } else {
            None
        };
        
        // Function body
        let body = if self.match_token(TokenType::LeftBrace) {
            Some(self.parse_block()?)
        } else if self.match_token(TokenType::Equal) {
            // Expression body (single expression functions)
            let expr = self.parse_expression()?;
            self.consume(TokenType::Semicolon, "Expected ';' after expression body")?;
            Some(Block {
                statements: vec![Statement::Expression { expr }]
            })
        } else {
            None // Abstract function
        };
        
        Ok(Item {
            visibility,
            kind: ItemKind::Function(Function {
                name,
                type_params,
                params,
                return_type,
                body,
                modifiers,
                where_clause,
            })
        })
    }
    
    // Parse struct declaration
    fun parse_struct(mut self, visibility: Visibility) -> Result<Item, str> {
        self.consume(TokenType::KeywordStruct, "Expected 'struct'")?;
        
        let name = self.consume(TokenType::Identifier, "Expected struct name")?.lexeme.to_string();
        
        // Generic type parameters
        let type_params = if self.match_token(TokenType::Less) {
            self.parse_type_parameters()?
        } else {
            Vec::new()
        };
        
        // Parent types (inheritance/traits)
        let parents = if self.match_token(TokenType::Colon) {
            self.parse_type_list()?
        } else {
            Vec::new()
        };
        
        // Struct body
        self.consume(TokenType::LeftBrace, "Expected '{' after struct declaration")?;
        
        let mut fields = Vec::new();
        
        while !self.check(TokenType::RightBrace) && !self.is_at_end() {
            let field_visibility = if self.match_token(TokenType::KeywordPub) {
                Visibility::Public
            } else {
                Visibility::Private
            };
            
            let field_name = self.consume(TokenType::Identifier, "Expected field name")?.lexeme.to_string();
            self.consume(TokenType::Colon, "Expected ':' after field name")?;
            let field_type = self.parse_type()?;
            
            fields.push(Field {
                name: field_name,
                field_type: field_type,
                visibility: field_visibility,
            });
            
            if !self.match_token(TokenType::Comma) {
                break;
            }
        }
        
        self.consume(TokenType::RightBrace, "Expected '}' after struct fields")?;
        
        Ok(Item {
            visibility,
            kind: ItemKind::Struct(Struct {
                name,
                type_params,
                fields,
                parents,
            })
        })
    }
    
    // Parse data class (Kotlin-inspired)
    fun parse_data_class(mut self, visibility: Visibility) -> Result<Item, str> {
        self.consume(TokenType::KeywordData, "Expected 'data'")?;
        self.consume(TokenType::KeywordStruct, "Expected 'struct' after 'data'")?;
        
        let name = self.consume(TokenType::Identifier, "Expected data class name")?.lexeme.to_string();
        
        // Generic type parameters
        let type_params = if self.match_token(TokenType::Less) {
            self.parse_type_parameters()?
        } else {
            Vec::new()
        };
        
        // Primary constructor parameters
        self.consume(TokenType::LeftParen, "Expected '(' after data class name")?;
        let params = self.parse_data_class_parameters()?;
        self.consume(TokenType::RightParen, "Expected ')' after parameters")?;
        
        // Optional body for additional methods
        let body = if self.match_token(TokenType::LeftBrace) {
            let mut methods = Vec::new();
            
            while !self.check(TokenType::RightBrace) && !self.is_at_end() {
                if self.match_token(TokenType::KeywordFun) {
                    // Parse method
                    self.current -= 1; // Back up to re-parse function
                    let method = self.parse_function(Visibility::Public)?;
                    methods.push(method);
                } else {
                    return Err("Only functions allowed in data class body".to_string());
                }
            }
            
            self.consume(TokenType::RightBrace, "Expected '}'")?;
            Some(methods)
        } else {
            None
        };
        
        Ok(Item {
            visibility,
            kind: ItemKind::DataClass(DataClass {
                name,
                type_params,
                params,
                body,
            })
        })
    }
    
    // Parse sealed class (Kotlin-inspired)
    fun parse_sealed_class(mut self, visibility: Visibility) -> Result<Item, str> {
        self.consume(TokenType::KeywordSealed, "Expected 'sealed'")?;
        self.consume(TokenType::KeywordStruct, "Expected 'struct' after 'sealed'")?;
        
        let name = self.consume(TokenType::Identifier, "Expected sealed class name")?.lexeme.to_string();
        
        // Generic type parameters
        let type_params = if self.match_token(TokenType::Less) {
            self.parse_type_parameters()?
        } else {
            Vec::new()
        };
        
        self.consume(TokenType::LeftBrace, "Expected '{' after sealed class declaration")?;
        
        let mut variants = Vec::new();
        
        while !self.check(TokenType::RightBrace) && !self.is_at_end() {
            let variant_name = self.consume(TokenType::Identifier, "Expected variant name")?.lexeme.to_string();
            
            // Variant parameters (if any)
            let params = if self.match_token(TokenType::LeftParen) {
                let params = self.parse_parameter_list()?;
                self.consume(TokenType::RightParen, "Expected ')' after variant parameters")?;
                Some(params)
            } else {
                None
            };
            
            variants.push(Variant {
                name: variant_name,
                params,
            });
            
            if !self.match_token(TokenType::Comma) {
                break;
            }
        }
        
        self.consume(TokenType::RightBrace, "Expected '}' after sealed class variants")?;
        
        Ok(Item {
            visibility,
            kind: ItemKind::SealedClass(SealedClass {
                name,
                type_params,
                variants,
            })
        })
    }
    
    // Parse expression
    fun parse_expression(mut self) -> Result<Expression, str> {
        self.parse_assignment()
    }
    
    // Parse assignment expression
    fun parse_assignment(mut self) -> Result<Expression, str> {
        let expr = self.parse_logical_or()?;
        
        if self.match_any(&[
            TokenType::Equal,
            TokenType::PlusEqual,
            TokenType::MinusEqual,
            TokenType::StarEqual,
            TokenType::SlashEqual,
        ]) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_assignment()?;
            
            return Ok(Expression::Assignment {
                target: Box::new(expr),
                operator,
                value: Box::new(right),
            });
        }
        
        Ok(expr)
    }
    
    // Parse logical OR expression
    fun parse_logical_or(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_logical_and()?;
        
        while self.match_token(TokenType::PipePipe) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_logical_and()?;
            expr = Expression::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }
        
        Ok(expr)
    }
    
    // Parse logical AND expression
    fun parse_logical_and(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_equality()?;
        
        while self.match_token(TokenType::AmpersandAmpersand) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_equality()?;
            expr = Expression::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }
        
        Ok(expr)
    }
    
    // Parse equality expression
    fun parse_equality(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_comparison()?;
        
        while self.match_any(&[TokenType::EqualEqual, TokenType::BangEqual]) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_comparison()?;
            expr = Expression::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }
        
        Ok(expr)
    }
    
    // Parse comparison expression
    fun parse_comparison(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_term()?;
        
        while self.match_any(&[
            TokenType::Greater,
            TokenType::GreaterEqual,
            TokenType::Less,
            TokenType::LessEqual,
        ]) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_term()?;
            expr = Expression::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }
        
        Ok(expr)
    }
    
    // Parse term expression (+ and -)
    fun parse_term(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_factor()?;
        
        while self.match_any(&[TokenType::Minus, TokenType::Plus]) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_factor()?;
            expr = Expression::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }
        
        Ok(expr)
    }
    
    // Parse factor expression (*, /, %)
    fun parse_factor(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_unary()?;
        
        while self.match_any(&[TokenType::Slash, TokenType::Star, TokenType::Percent]) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_unary()?;
            expr = Expression::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }
        
        Ok(expr)
    }
    
    // Parse unary expression
    fun parse_unary(mut self) -> Result<Expression, str> {
        if self.match_any(&[TokenType::Bang, TokenType::Minus]) {
            let operator = self.previous().token_type.clone();
            let right = self.parse_unary()?;
            return Ok(Expression::Unary {
                operator,
                operand: Box::new(right),
            });
        }
        
        self.parse_postfix()
    }
    
    // Parse postfix expression (calls, indexing, member access)
    fun parse_postfix(mut self) -> Result<Expression, str> {
        let mut expr = self.parse_primary()?;
        
        loop {
            match self.peek().token_type {
                TokenType::LeftParen => {
                    // Function call
                    self.advance();
                    let args = self.parse_argument_list()?;
                    self.consume(TokenType::RightParen, "Expected ')' after arguments")?;
                    expr = Expression::Call {
                        callee: Box::new(expr),
                        args,
                    };
                },
                TokenType::LeftBracket => {
                    // Array indexing
                    self.advance();
                    let index = self.parse_expression()?;
                    self.consume(TokenType::RightBracket, "Expected ']' after index")?;
                    expr = Expression::Index {
                        object: Box::new(expr),
                        index: Box::new(index),
                    };
                },
                TokenType::Dot => {
                    // Member access
                    self.advance();
                    let member = self.consume(TokenType::Identifier, "Expected member name after '.'")?;
                    expr = Expression::Member {
                        object: Box::new(expr),
                        member: member.lexeme.to_string(),
                    };
                },
                TokenType::QuestionDot => {
                    // Safe call operator (?.)
                    self.advance();
                    let member = self.consume(TokenType::Identifier, "Expected member name after '?.'")?;
                    expr = Expression::SafeCall {
                        object: Box::new(expr),
                        member: member.lexeme.to_string(),
                    };
                },
                _ => break,
            }
        }
        
        Ok(expr)
    }
    
    // Parse primary expression
    fun parse_primary(mut self) -> Result<Expression, str> {
        match self.peek().token_type {
            TokenType::KeywordTrue => {
                self.advance();
                Ok(Expression::Literal { value: LiteralValue::Boolean(true) })
            },
            TokenType::KeywordFalse => {
                self.advance();
                Ok(Expression::Literal { value: LiteralValue::Boolean(false) })
            },
            TokenType::KeywordNull => {
                self.advance();
                Ok(Expression::Literal { value: LiteralValue::Null })
            },
            TokenType::IntegerLiteral => {
                let token = self.advance();
                let value = token.lexeme.parse::<i64>().map_err(|_| "Invalid integer literal")?;
                Ok(Expression::Literal { value: LiteralValue::Integer(value) })
            },
            TokenType::FloatLiteral => {
                let token = self.advance();
                let value = token.lexeme.parse::<f64>().map_err(|_| "Invalid float literal")?;
                Ok(Expression::Literal { value: LiteralValue::Float(value) })
            },
            TokenType::StringLiteral => {
                let token = self.advance();
                // Remove quotes and handle escape sequences
                let value = token.lexeme.trim_matches('"').to_string();
                Ok(Expression::Literal { value: LiteralValue::String(value) })
            },
            TokenType::Identifier => {
                let token = self.advance();
                Ok(Expression::Identifier { name: token.lexeme.to_string() })
            },
            TokenType::LeftParen => {
                self.advance();
                let expr = self.parse_expression()?;
                self.consume(TokenType::RightParen, "Expected ')' after expression")?;
                Ok(expr)
            },
            TokenType::LeftBracket => {
                // Array literal
                self.advance();
                let elements = self.parse_expression_list()?;
                self.consume(TokenType::RightBracket, "Expected ']' after array elements")?;
                Ok(Expression::Array { elements })
            },
            TokenType::KeywordIf => {
                self.parse_if_expression()
            },
            TokenType::KeywordMatch => {
                self.parse_match_expression()
            },
            _ => Err(format!("Unexpected token: {}", self.peek().lexeme)),
        }
    }
    
    // Helper methods for parsing utilities
    
    // Check if current token matches type
    fun check(self, token_type: TokenType) -> bool {
        if self.is_at_end() {
            false
        } else {
            self.peek().token_type == token_type
        }
    }
    
    // Check if current token matches any of the given types
    fun match_any(mut self, types: &[TokenType]) -> bool {
        for token_type in types {
            if self.check(*token_type) {
                self.advance();
                return true;
            }
        }
        false
    }
    
    // Match single token type
    fun match_token(mut self, token_type: TokenType) -> bool {
        if self.check(token_type) {
            self.advance();
            true
        } else {
            false
        }
    }
    
    // Advance to next token
    fun advance(mut self) -> Token {
        if !self.is_at_end() {
            self.current += 1;
        }
        self.previous()
    }
    
    // Check if at end of tokens
    fun is_at_end(self) -> bool {
        self.peek().token_type == TokenType::EOF
    }
    
    // Get current token without advancing
    fun peek(self) -> Token {
        self.tokens[self.current as usize].clone()
    }
    
    // Get previous token
    fun previous(self) -> Token {
        self.tokens[(self.current - 1) as usize].clone()
    }
    
    // Consume expected token or error
    fun consume(mut self, token_type: TokenType, message: str) -> Result<Token, str> {
        if self.check(token_type) {
            Ok(self.advance())
        } else {
            Err(format!("{}: got {}", message, self.peek().lexeme))
        }
    }
    
    // Error recovery - synchronize to next statement
    fun synchronize(mut self) {
        self.advance();
        
        while !self.is_at_end() {
            if self.previous().token_type == TokenType::Semicolon {
                return;
            }
            
            match self.peek().token_type {
                TokenType::KeywordFun | TokenType::KeywordStruct |
                TokenType::KeywordEnum | TokenType::KeywordIf |
                TokenType::KeywordWhile | TokenType::KeywordFor |
                TokenType::KeywordReturn => return,
                _ => {},
            }
            
            self.advance();
        }
    }
    
    // Additional parsing methods would be implemented here...
    // For brevity, showing the main structure and key methods
    
    // Placeholder implementations for methods referenced above
    fun parse_type(mut self) -> Result<Type, str> { 
        // Implementation for type parsing
        Ok(Type::Unknown)
    }
    
    fun parse_parameter_list(mut self) -> Result<Vec<Parameter>, str> { 
        Ok(Vec::new()) 
    }
    
    fun parse_type_parameters(mut self) -> Result<Vec<TypeParameter>, str> { 
        Ok(Vec::new()) 
    }
    
    fun parse_where_clause(mut self) -> Result<WhereClause, str> { 
        Ok(WhereClause { constraints: Vec::new() })
    }
    
    fun parse_block(mut self) -> Result<Block, str> { 
        Ok(Block { statements: Vec::new() })
    }
    
    fun parse_enum(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Enum parsing not implemented".to_string())
    }
    
    fun parse_trait(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Trait parsing not implemented".to_string())
    }
    
    fun parse_impl(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Impl parsing not implemented".to_string())
    }
    
    fun parse_interface(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Interface parsing not implemented".to_string())
    }
    
    fun parse_object(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Object parsing not implemented".to_string())
    }
    
    fun parse_import(mut self) -> Result<Item, str> { 
        Err("Import parsing not implemented".to_string())
    }
    
    fun parse_export(mut self) -> Result<Item, str> { 
        Err("Export parsing not implemented".to_string())
    }
    
    fun parse_const(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Const parsing not implemented".to_string())
    }
    
    fun parse_static(mut self, visibility: Visibility) -> Result<Item, str> { 
        Err("Static parsing not implemented".to_string())
    }
    
    fun parse_data_class_parameters(mut self) -> Result<Vec<DataClassParameter>, str> { 
        Ok(Vec::new())
    }
    
    fun parse_type_list(mut self) -> Result<Vec<Type>, str> { 
        Ok(Vec::new())
    }
    
    fun parse_argument_list(mut self) -> Result<Vec<Expression>, str> { 
        Ok(Vec::new())
    }
    
    fun parse_expression_list(mut self) -> Result<Vec<Expression>, str> { 
        Ok(Vec::new())
    }
    
    fun parse_if_expression(mut self) -> Result<Expression, str> { 
        Err("If expression parsing not implemented".to_string())
    }
    
    fun parse_match_expression(mut self) -> Result<Expression, str> { 
        Err("Match expression parsing not implemented".to_string())
    }
}