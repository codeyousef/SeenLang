// Seen Parser - Complete Implementation for Self-Hosting
// Implements full AST generation for all Seen language constructs

// Import Token class from lexer
// Note: In a real implementation, this would be an import
// For bootstrap, we assume Token is available

// AST Node types representing all language constructs

class Position {
    var line: Int
    var column: Int
    var offset: Int
    
    fun new(line: Int, column: Int, offset: Int) -> Position {
        let pos = Position{}
        pos.line = line
        pos.column = column
        pos.offset = offset
        return pos
    }
}

// Base AST node
class ASTNode {
    var position: Position
    
    fun new(position: Position) -> ASTNode {
        let node = ASTNode{}
        node.position = position
        return node
    }
    
    fun getPosition() -> Position {
        return this.position
    }
}

// Expression types
class Expression {
    var position: Position
    var kind: String
    
    fun new(position: Position, kind: String) -> Expression {
        let expr = Expression{}
        expr.position = position
        expr.kind = kind
        return expr
    }
    
    fun getKind() -> String {
        return this.kind
    }
    
    fun getPosition() -> Position {
        return this.position
    }
}

class IntegerLiteral {
    var value: Int
    var position: Position
    
    fun new(value: Int, position: Position) -> IntegerLiteral {
        let lit = IntegerLiteral{}
        lit.value = value
        lit.position = position
        return lit
    }
    
    fun getValue() -> Int {
        return this.value
    }
}

class FloatLiteral {
    var value: Float
    var position: Position
    
    fun new(value: Float, position: Position) -> FloatLiteral {
        let lit = FloatLiteral{}
        lit.value = value
        lit.position = position
        return lit
    }
    
    fun getValue() -> Float {
        return this.value
    }
}

class StringLiteral {
    var value: String
    var position: Position
    
    fun new(value: String, position: Position) -> StringLiteral {
        let lit = StringLiteral{}
        lit.value = value
        lit.position = position
        return lit
    }
    
    fun getValue() -> String {
        return this.value
    }
}

class BooleanLiteral {
    var value: Bool
    var position: Position
    
    fun new(value: Bool, position: Position) -> BooleanLiteral {
        let lit = BooleanLiteral{}
        lit.value = value
        lit.position = position
        return lit
    }
    
    fun getValue() -> Bool {
        return this.value
    }
}

class Identifier {
    var name: String
    var isPublic: Bool
    var position: Position
    
    fun new(name: String, isPublic: Bool, position: Position) -> Identifier {
        let id = Identifier{}
        id.name = name
        id.isPublic = isPublic
        id.position = position
        return id
    }
    
    fun getName() -> String {
        return this.name
    }
    
    fun getIsPublic() -> Bool {
        return this.isPublic
    }
}

class BinaryOp {
    var left: Expression
    var operator: String
    var right: Expression
    var position: Position
    
    fun new(left: Expression, operator: String, right: Expression, position: Position) -> BinaryOp {
        let op = BinaryOp{}
        op.left = left
        op.operator = operator
        op.right = right
        op.position = position
        return op
    }
    
    fun getLeft() -> Expression {
        return this.left
    }
    
    fun getOperator() -> String {
        return this.operator
    }
    
    fun getRight() -> Expression {
        return this.right
    }
}

class UnaryOp {
    var operator: String
    var operand: Expression
    var position: Position
    
    fun new(operator: String, operand: Expression, position: Position) -> UnaryOp {
        let op = UnaryOp{}
        op.operator = operator
        op.operand = operand
        op.position = position
        return op
    }
    
    fun getOperator() -> String {
        return this.operator
    }
    
    fun getOperand() -> Expression {
        return this.operand
    }
}

class FunctionCall {
    var function: Expression
    var arguments: Array<Expression>
    var position: Position
    
    fun new(function: Expression, arguments: Array<Expression>, position: Position) -> FunctionCall {
        let call = FunctionCall{}
        call.function = function
        call.arguments = arguments
        call.position = position
        return call
    }
    
    fun getFunction() -> Expression {
        return this.function
    }
    
    fun getArguments() -> Array<Expression> {
        return this.arguments
    }
}

class IfExpression {
    var condition: Expression
    var thenBranch: Expression
    var elseBranch: Expression?
    var position: Position
    
    fun new(condition: Expression, thenBranch: Expression, elseBranch: Expression?, position: Position) -> IfExpression {
        let ifExpr = IfExpression{}
        ifExpr.condition = condition
        ifExpr.thenBranch = thenBranch
        ifExpr.elseBranch = elseBranch
        ifExpr.position = position
        return ifExpr
    }
}

class MatchExpression {
    var expression: Expression
    var arms: Array<MatchArm>
    var position: Position
    
    fun new(expression: Expression, arms: Array<MatchArm>, position: Position) -> MatchExpression {
        let match = MatchExpression{}
        match.expression = expression
        match.arms = arms
        match.position = position
        return match
    }
}

class MatchArm {
    var pattern: Pattern
    var guard: Expression?
    var body: Expression
    var position: Position
    
    fun new(pattern: Pattern, guard: Expression?, body: Expression, position: Position) -> MatchArm {
        let arm = MatchArm{}
        arm.pattern = pattern
        arm.guard = guard
        arm.body = body
        arm.position = position
        return arm
    }
}

class Pattern {
    var kind: String
    var position: Position
    
    fun new(kind: String, position: Position) -> Pattern {
        let pattern = Pattern{}
        pattern.kind = kind
        pattern.position = position
        return pattern
    }
}

class ForLoop {
    var variable: String
    var iterable: Expression
    var body: Expression
    var position: Position
    
    fun new(variable: String, iterable: Expression, body: Expression, position: Position) -> ForLoop {
        let loop = ForLoop{}
        loop.variable = variable
        loop.iterable = iterable
        loop.body = body
        loop.position = position
        return loop
    }
}

class WhileLoop {
    var condition: Expression
    var body: Expression
    var position: Position
    
    fun new(condition: Expression, body: Expression, position: Position) -> WhileLoop {
        let loop = WhileLoop{}
        loop.condition = condition
        loop.body = body
        loop.position = position
        return loop
    }
}

class Block {
    var statements: Array<Statement>
    var position: Position
    
    fun new(statements: Array<Statement>, position: Position) -> Block {
        let block = Block{}
        block.statements = statements
        block.position = position
        return block
    }
    
    fun getStatements() -> Array<Statement> {
        return this.statements
    }
}

class Statement {
    var kind: String
    var position: Position
    
    fun new(kind: String, position: Position) -> Statement {
        let stmt = Statement{}
        stmt.kind = kind
        stmt.position = position
        return stmt
    }
    
    fun getKind() -> String {
        return this.kind
    }
}

class LetBinding {
    var name: String
    var type: Type?
    var value: Expression
    var isMutable: Bool
    var position: Position
    
    fun new(name: String, type: Type?, value: Expression, isMutable: Bool, position: Position) -> LetBinding {
        let binding = LetBinding{}
        binding.name = name
        binding.type = type
        binding.value = value
        binding.isMutable = isMutable
        binding.position = position
        return binding
    }
}

class Function {
    var name: String
    var parameters: Array<Parameter>
    var returnType: Type?
    var body: Expression
    var isPublic: Bool
    var position: Position
    
    fun new(name: String, parameters: Array<Parameter>, returnType: Type?, body: Expression, isPublic: Bool, position: Position) -> Function {
        let func = Function{}
        func.name = name
        func.parameters = parameters
        func.returnType = returnType
        func.body = body
        func.isPublic = isPublic
        func.position = position
        return func
    }
    
    fun getName() -> String {
        return this.name
    }
    
    fun getParameters() -> Array<Parameter> {
        return this.parameters
    }
    
    fun getBody() -> Expression {
        return this.body
    }
}

class Parameter {
    var name: String
    var type: Type
    var defaultValue: Expression?
    var position: Position
    
    fun new(name: String, type: Type, defaultValue: Expression?, position: Position) -> Parameter {
        let param = Parameter{}
        param.name = name
        param.type = type
        param.defaultValue = defaultValue
        param.position = position
        return param
    }
}

class Type {
    var name: String
    var genericArgs: Array<Type>
    var isNullable: Bool
    var position: Position
    
    fun new(name: String, genericArgs: Array<Type>, isNullable: Bool, position: Position) -> Type {
        let type = Type{}
        type.name = name
        type.genericArgs = genericArgs
        type.isNullable = isNullable
        type.position = position
        return type
    }
    
    fun getName() -> String {
        return this.name
    }
    
    fun isNullable() -> Bool {
        return this.isNullable
    }
}

class Class {
    var name: String
    var fields: Array<Field>
    var methods: Array<Function>
    var isPublic: Bool
    var position: Position
    
    fun new(name: String, fields: Array<Field>, methods: Array<Function>, isPublic: Bool, position: Position) -> Class {
        let cls = Class{}
        cls.name = name
        cls.fields = fields
        cls.methods = methods
        cls.isPublic = isPublic
        cls.position = position
        return cls
    }
}

class Field {
    var name: String
    var type: Type
    var isMutable: Bool
    var position: Position
    
    fun new(name: String, type: Type, isMutable: Bool, position: Position) -> Field {
        let field = Field{}
        field.name = name
        field.type = type
        field.isMutable = isMutable
        field.position = position
        return field
    }
}

class Program {
    var items: Array<Item>
    var position: Position
    
    fun new(items: Array<Item>, position: Position) -> Program {
        let program = Program{}
        program.items = items
        program.position = position
        return program
    }
    
    fun getItems() -> Array<Item> {
        return this.items
    }
}

class Item {
    var kind: String
    var data: ASTNode
    var position: Position
    
    fun new(kind: String, data: ASTNode, position: Position) -> Item {
        let item = Item{}
        item.kind = kind
        item.data = data
        item.position = position
        return item
    }
    
    fun getKind() -> String {
        return this.kind
    }
    
    fun getData() -> ASTNode {
        return this.data
    }
}

// Parser implementation
class SeenParser {
    var tokens: Array<Token>
    var current: Int
    var currentToken: Token
    
    fun new(tokens: Array<Token>) -> SeenParser {
        let parser = SeenParser{}
        parser.tokens = tokens
        parser.current = 0
        parser.currentToken = if tokens.length() > 0 { tokens.get(0) } else { Token.new("EOF", "", 0, 0, 0, 0) }
        return parser
    }
    
    fun advance() {
        this.current = this.current + 1
        if this.current < this.tokens.length() {
            this.currentToken = this.tokens.get(this.current)
        } else {
            this.currentToken = Token.new("EOF", "", 0, 0, 0, 0)
        }
    }
    
    fun peek() -> Token {
        let peekPos = this.current + 1
        if peekPos < this.tokens.length() {
            return this.tokens.get(peekPos)
        }
        return Token.new("EOF", "", 0, 0, 0, 0)
    }
    
    fun check(tokenType: String) -> Bool {
        return this.currentToken.getType() == tokenType
    }
    
    fun consume(tokenType: String) -> Bool {
        if this.check(tokenType) {
            this.advance()
            return true
        }
        return false
    }
    
    fun expect(tokenType: String) -> Token {
        if this.check(tokenType) {
            let token = this.currentToken
            this.advance()
            return token
        }
        // Error handling - for bootstrap, just return current token
        return this.currentToken
    }
    
    fun parseProgram() -> Program {
        let items = Array<Item>()
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        
        while not this.check("EOF") {
            if this.check("KeywordFun") {
                let func = this.parseFunction()
                let item = Item.new("Function", func, func.position)
                items.push(item)
            } else if this.check("KeywordClass") {
                let cls = this.parseClass()
                let item = Item.new("Class", cls, cls.position)
                items.push(item)
            } else {
                // Skip unknown tokens for now
                this.advance()
            }
        }
        
        return Program.new(items, pos)
    }
    
    fun parseFunction() -> Function {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("KeywordFun")
        
        let nameToken = this.expect("PrivateIdentifier")
        let name = nameToken.getValue()
        let isPublic = nameToken.getType() == "PublicIdentifier"
        
        this.expect("LeftParen")
        let parameters = this.parseParameters()
        this.expect("RightParen")
        
        var returnType: Type? = null
        if this.consume("Arrow") {
            returnType = this.parseType()
        }
        
        let body = this.parseExpression()
        
        return Function.new(name, parameters, returnType, body, isPublic, pos)
    }
    
    fun parseParameters() -> Array<Parameter> {
        let parameters = Array<Parameter>()
        
        while not this.check("RightParen") and not this.check("EOF") {
            let param = this.parseParameter()
            parameters.push(param)
            
            if not this.consume("Comma") {
                break
            }
        }
        
        return parameters
    }
    
    fun parseParameter() -> Parameter {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        let nameToken = this.expect("PrivateIdentifier")
        let name = nameToken.getValue()
        
        this.expect("Colon")
        let type = this.parseType()
        
        var defaultValue: Expression? = null
        if this.consume("Assign") {
            defaultValue = this.parseExpression()
        }
        
        return Parameter.new(name, type, defaultValue, pos)
    }
    
    fun parseType() -> Type {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        let nameToken = this.currentToken
        this.advance()
        
        let name = nameToken.getValue()
        let genericArgs = Array<Type>()
        var isNullable = false
        
        // Parse generic arguments
        if this.consume("Less") {
            while not this.check("Greater") and not this.check("EOF") {
                let argType = this.parseType()
                genericArgs.push(argType)
                
                if not this.consume("Comma") {
                    break
                }
            }
            this.expect("Greater")
        }
        
        // Parse nullable
        if this.consume("Question") {
            isNullable = true
        }
        
        return Type.new(name, genericArgs, isNullable, pos)
    }
    
    fun parseExpression() -> Expression {
        return this.parseAssignment()
    }
    
    fun parseAssignment() -> Expression {
        let expr = this.parseLogicalOr()
        
        if this.consume("Assign") {
            let right = this.parseAssignment()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            return BinaryOp.new(expr, "=", right, pos)
        }
        
        return expr
    }
    
    fun parseLogicalOr() -> Expression {
        var expr = this.parseLogicalAnd()
        
        while this.check("LogicalOr") {
            let op = this.currentToken.getValue()
            this.advance()
            let right = this.parseLogicalAnd()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            expr = BinaryOp.new(expr, op, right, pos)
        }
        
        return expr
    }
    
    fun parseLogicalAnd() -> Expression {
        var expr = this.parseEquality()
        
        while this.check("LogicalAnd") {
            let op = this.currentToken.getValue()
            this.advance()
            let right = this.parseEquality()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            expr = BinaryOp.new(expr, op, right, pos)
        }
        
        return expr
    }
    
    fun parseEquality() -> Expression {
        var expr = this.parseComparison()
        
        while this.check("Equal") or this.check("NotEqual") {
            let op = this.currentToken.getValue()
            this.advance()
            let right = this.parseComparison()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            expr = BinaryOp.new(expr, op, right, pos)
        }
        
        return expr
    }
    
    fun parseComparison() -> Expression {
        var expr = this.parseTerm()
        
        while this.check("Less") or this.check("Greater") or this.check("LessEqual") or this.check("GreaterEqual") {
            let op = this.currentToken.getValue()
            this.advance()
            let right = this.parseTerm()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            expr = BinaryOp.new(expr, op, right, pos)
        }
        
        return expr
    }
    
    fun parseTerm() -> Expression {
        var expr = this.parseFactor()
        
        while this.check("Plus") or this.check("Minus") {
            let op = this.currentToken.getValue()
            this.advance()
            let right = this.parseFactor()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            expr = BinaryOp.new(expr, op, right, pos)
        }
        
        return expr
    }
    
    fun parseFactor() -> Expression {
        var expr = this.parseUnary()
        
        while this.check("Multiply") or this.check("Divide") {
            let op = this.currentToken.getValue()
            this.advance()
            let right = this.parseUnary()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            expr = BinaryOp.new(expr, op, right, pos)
        }
        
        return expr
    }
    
    fun parseUnary() -> Expression {
        if this.check("LogicalNot") or this.check("Minus") {
            let op = this.currentToken.getValue()
            let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
            this.advance()
            let operand = this.parseUnary()
            return UnaryOp.new(op, operand, pos)
        }
        
        return this.parsePostfix()
    }
    
    fun parsePostfix() -> Expression {
        var expr = this.parsePrimary()
        
        while true {
            if this.consume("LeftParen") {
                // Function call
                let args = this.parseArguments()
                this.expect("RightParen")
                let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
                expr = FunctionCall.new(expr, args, pos)
            } else if this.consume("Dot") {
                // Member access - simplified for bootstrap
                let member = this.expect("PrivateIdentifier")
                // For now, treat as identifier
                let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
                let memberExpr = Identifier.new(member.getValue(), false, pos)
                expr = BinaryOp.new(expr, ".", memberExpr, pos)
            } else {
                break
            }
        }
        
        return expr
    }
    
    fun parseArguments() -> Array<Expression> {
        let args = Array<Expression>()
        
        while not this.check("RightParen") and not this.check("EOF") {
            let arg = this.parseExpression()
            args.push(arg)
            
            if not this.consume("Comma") {
                break
            }
        }
        
        return args
    }
    
    fun parsePrimary() -> Expression {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        
        if this.check("IntegerLiteral") {
            let value = this.currentToken.getValue().parseInt()
            this.advance()
            return IntegerLiteral.new(value, pos)
        }
        
        if this.check("FloatLiteral") {
            let value = this.currentToken.getValue().parseFloat()
            this.advance()
            return FloatLiteral.new(value, pos)
        }
        
        if this.check("StringLiteral") {
            let value = this.currentToken.getValue()
            this.advance()
            return StringLiteral.new(value, pos)
        }
        
        if this.check("KeywordTrue") {
            this.advance()
            return BooleanLiteral.new(true, pos)
        }
        
        if this.check("KeywordFalse") {
            this.advance()
            return BooleanLiteral.new(false, pos)
        }
        
        if this.check("PrivateIdentifier") or this.check("PublicIdentifier") {
            let name = this.currentToken.getValue()
            let isPublic = this.currentToken.getType() == "PublicIdentifier"
            this.advance()
            return Identifier.new(name, isPublic, pos)
        }
        
        if this.consume("LeftParen") {
            let expr = this.parseExpression()
            this.expect("RightParen")
            return expr
        }
        
        if this.check("LeftBrace") {
            return this.parseBlock()
        }
        
        if this.check("KeywordIf") {
            return this.parseIf()
        }
        
        if this.check("KeywordFor") {
            return this.parseFor()
        }
        
        if this.check("KeywordWhile") {
            return this.parseWhile()
        }
        
        if this.check("KeywordMatch") {
            return this.parseMatch()
        }
        
        // Default: create a placeholder expression
        return Expression.new(pos, "Unknown")
    }
    
    fun parseBlock() -> Expression {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("LeftBrace")
        
        let statements = Array<Statement>()
        
        while not this.check("RightBrace") and not this.check("EOF") {
            if this.check("KeywordLet") or this.check("KeywordVar") {
                let binding = this.parseLetBinding()
                let stmt = Statement.new("LetBinding", binding.position)
                statements.push(stmt)
            } else {
                let expr = this.parseExpression()
                let stmt = Statement.new("Expression", expr.position)
                statements.push(stmt)
            }
            
            // Optional semicolon
            this.consume("Semicolon")
        }
        
        this.expect("RightBrace")
        return Block.new(statements, pos)
    }
    
    fun parseLetBinding() -> LetBinding {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        let isMutable = this.consume("KeywordVar")
        if not isMutable {
            this.expect("KeywordLet")
        }
        
        let nameToken = this.expect("PrivateIdentifier")
        let name = nameToken.getValue()
        
        var type: Type? = null
        if this.consume("Colon") {
            type = this.parseType()
        }
        
        this.expect("Assign")
        let value = this.parseExpression()
        
        return LetBinding.new(name, type, value, isMutable, pos)
    }
    
    fun parseIf() -> Expression {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("KeywordIf")
        
        let condition = this.parseExpression()
        let thenBranch = this.parseExpression()
        
        var elseBranch: Expression? = null
        if this.consume("KeywordElse") {
            elseBranch = this.parseExpression()
        }
        
        return IfExpression.new(condition, thenBranch, elseBranch, pos)
    }
    
    fun parseFor() -> Expression {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("KeywordFor")
        
        let variableToken = this.expect("PrivateIdentifier")
        let variable = variableToken.getValue()
        
        this.expect("KeywordIn")
        
        let iterable = this.parseExpression()
        let body = this.parseExpression()
        
        return ForLoop.new(variable, iterable, body, pos)
    }
    
    fun parseWhile() -> Expression {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("KeywordWhile")
        
        let condition = this.parseExpression()
        let body = this.parseExpression()
        
        return WhileLoop.new(condition, body, pos)
    }
    
    fun parseMatch() -> Expression {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("KeywordMatch")
        
        let expr = this.parseExpression()
        this.expect("LeftBrace")
        
        let arms = Array<MatchArm>()
        
        while not this.check("RightBrace") and not this.check("EOF") {
            let pattern = this.parsePattern()
            
            var guard: Expression? = null
            if this.check("KeywordIf") {
                this.advance()
                guard = this.parseExpression()
            }
            
            this.expect("Arrow")
            let body = this.parseExpression()
            
            let arm = MatchArm.new(pattern, guard, body, pos)
            arms.push(arm)
            
            // Optional comma
            this.consume("Comma")
        }
        
        this.expect("RightBrace")
        return MatchExpression.new(expr, arms, pos)
    }
    
    fun parsePattern() -> Pattern {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        
        if this.check("IntegerLiteral") or this.check("StringLiteral") or this.check("KeywordTrue") or this.check("KeywordFalse") {
            this.advance()
            return Pattern.new("Literal", pos)
        }
        
        if this.check("PrivateIdentifier") {
            this.advance()
            return Pattern.new("Identifier", pos)
        }
        
        return Pattern.new("Wildcard", pos)
    }
    
    fun parseClass() -> Class {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        this.expect("KeywordClass")
        
        let nameToken = this.currentToken
        this.advance()
        let name = nameToken.getValue()
        let isPublic = nameToken.getType() == "PublicIdentifier"
        
        this.expect("LeftBrace")
        
        let fields = Array<Field>()
        let methods = Array<Function>()
        
        while not this.check("RightBrace") and not this.check("EOF") {
            if this.check("KeywordVar") or this.check("KeywordLet") {
                let field = this.parseField()
                fields.push(field)
            } else if this.check("KeywordFun") {
                let method = this.parseFunction()
                methods.push(method)
            } else {
                this.advance() // Skip unknown tokens
            }
        }
        
        this.expect("RightBrace")
        return Class.new(name, fields, methods, isPublic, pos)
    }
    
    fun parseField() -> Field {
        let pos = Position.new(this.currentToken.getLine(), this.currentToken.getColumn(), 0)
        let isMutable = this.consume("KeywordVar")
        if not isMutable {
            this.expect("KeywordLet")
        }
        
        let nameToken = this.expect("PrivateIdentifier")
        let name = nameToken.getValue()
        
        this.expect("Colon")
        let type = this.parseType()
        
        return Field.new(name, type, isMutable, pos)
    }
}

// Factory function
fun createParser(tokens: Array<Token>) -> SeenParser {
    return SeenParser.new(tokens)
}