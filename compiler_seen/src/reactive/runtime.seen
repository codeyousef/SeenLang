// Self-hosted Seen Reactive Runtime
// Ported from Rust implementation with full reactive programming support
// Provides Observables, Flows, Subjects, Schedulers, and operators

import std.collections.HashMap;
import std.collections.Vec;
import std.core.Result;
import std.core.Option;
import std.core.RefCell;
import std.time.Instant;
import std.thread.Thread;

// Core reactive types
trait Observable<T> {
    fun subscribe(self, observer: Observer<T>) -> Subscription;
}

trait Observer<T> {
    fun on_next(mut self, value: T);
    fun on_error(mut self, error: str);
    fun on_completed(mut self);
}

trait Subscription {
    fun unsubscribe(mut self);
    fun is_unsubscribed(self) -> bool;
}

// Flow trait for cold observables
trait Flow<T> {
    fun collect(self, collector: FlowCollector<T>);
}

trait FlowCollector<T> {
    fun emit(mut self, value: T);
    fun emit_error(mut self, error: str);
    fun complete(mut self);
}

// Subject (hot observable)
trait Subject<T>: Observable<T> + Observer<T> {
    fun has_observers(self) -> bool;
}

// Scheduler for managing concurrency
trait Scheduler {
    fun schedule(self, action: Box<dyn Fn()>);
    fun schedule_delayed(self, action: Box<dyn Fn()>, delay_ms: i64);
    fun schedule_periodic(self, action: Box<dyn Fn()>, initial_delay_ms: i64, period_ms: i64) -> Subscription;
}

// Basic Observable implementation
struct SimpleObservable<T> {
    source: Box<dyn Fn(Observer<T>) -> Subscription>,
}

impl<T> SimpleObservable<T> {
    fun new(source: Box<dyn Fn(Observer<T>) -> Subscription>) -> Self {
        Self { source }
    }
    
    fun create(emitter: Box<dyn Fn(ObservableEmitter<T>)>) -> Self {
        Self::new(Box::new(move |observer| {
            let emitter_impl = ObservableEmitter::new(observer);
            emitter(emitter_impl.clone());
            emitter_impl.subscription()
        }))
    }
    
    fun just(value: T) -> Self {
        Self::new(Box::new(move |observer| {
            observer.on_next(value);
            observer.on_completed();
            EmptySubscription::new()
        }))
    }
    
    fun from_iter(iter: Vec<T>) -> Self {
        Self::new(Box::new(move |observer| {
            for value in iter {
                observer.on_next(value);
            }
            observer.on_completed();
            EmptySubscription::new()
        }))
    }
    
    fun error(error: str) -> Self {
        Self::new(Box::new(move |observer| {
            observer.on_error(error);
            EmptySubscription::new()
        }))
    }
    
    fun empty() -> Self {
        Self::new(Box::new(move |observer| {
            observer.on_completed();
            EmptySubscription::new()
        }))
    }
    
    fun never() -> Self {
        Self::new(Box::new(move |_observer| {
            // Never emits anything
            EmptySubscription::new()
        }))
    }
    
    fun interval(period_ms: i64, scheduler: Box<dyn Scheduler>) -> Self {
        Self::new(Box::new(move |observer| {
            let count = RefCell::new(0i64);
            scheduler.schedule_periodic(
                Box::new(move || {
                    let current = *count.borrow();
                    observer.on_next(current);
                    *count.borrow_mut() = current + 1;
                }),
                0,
                period_ms
            )
        }))
    }
    
    fun timer(delay_ms: i64, scheduler: Box<dyn Scheduler>) -> Self {
        Self::new(Box::new(move |observer| {
            scheduler.schedule_delayed(
                Box::new(move || {
                    observer.on_next(0i64);
                    observer.on_completed();
                }),
                delay_ms
            );
            EmptySubscription::new()
        }))
    }
}

impl<T> Observable<T> for SimpleObservable<T> {
    fun subscribe(self, observer: Observer<T>) -> Subscription {
        (self.source)(observer)
    }
}

// Observable operators
impl<T> SimpleObservable<T> {
    // Transformation operators
    fun map<U>(self, mapper: Box<dyn Fn(T) -> U>) -> SimpleObservable<U> {
        SimpleObservable::new(Box::new(move |observer| {
            self.subscribe(MapObserver::new(observer, mapper.clone()))
        }))
    }
    
    fun flat_map<U>(self, mapper: Box<dyn Fn(T) -> SimpleObservable<U>>) -> SimpleObservable<U> {
        SimpleObservable::new(Box::new(move |observer| {
            self.subscribe(FlatMapObserver::new(observer, mapper.clone()))
        }))
    }
    
    fun filter(self, predicate: Box<dyn Fn(&T) -> bool>) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(FilterObserver::new(observer, predicate.clone()))
        }))
    }
    
    fun take(self, count: i64) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(TakeObserver::new(observer, count))
        }))
    }
    
    fun skip(self, count: i64) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(SkipObserver::new(observer, count))
        }))
    }
    
    fun distinct_until_changed(self) -> Self 
    where T: PartialEq + Clone {
        Self::new(Box::new(move |observer| {
            self.subscribe(DistinctUntilChangedObserver::new(observer))
        }))
    }
    
    // Filtering operators
    fun first(self) -> Self {
        self.take(1)
    }
    
    fun last(self) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(LastObserver::new(observer))
        }))
    }
    
    // Combining operators
    fun merge(self, other: Self) -> Self {
        Self::new(Box::new(move |observer| {
            let subscription1 = self.subscribe(observer.clone());
            let subscription2 = other.subscribe(observer);
            CompositeSubscription::from_vec(vec![subscription1, subscription2])
        }))
    }
    
    fun combine_latest<U, R>(
        self, 
        other: SimpleObservable<U>, 
        combiner: Box<dyn Fn(T, U) -> R>
    ) -> SimpleObservable<R> {
        SimpleObservable::new(Box::new(move |observer| {
            CombineLatestObserver::new(observer, self, other, combiner.clone()).subscription()
        }))
    }
    
    fun zip<U, R>(
        self, 
        other: SimpleObservable<U>, 
        zipper: Box<dyn Fn(T, U) -> R>
    ) -> SimpleObservable<R> {
        SimpleObservable::new(Box::new(move |observer| {
            ZipObserver::new(observer, self, other, zipper.clone()).subscription()
        }))
    }
    
    // Utility operators
    fun delay(self, delay_ms: i64, scheduler: Box<dyn Scheduler>) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(DelayObserver::new(observer, delay_ms, scheduler.clone()))
        }))
    }
    
    fun timeout(self, timeout_ms: i64, scheduler: Box<dyn Scheduler>) -> Self {
        Self::new(Box::new(move |observer| {
            TimeoutObserver::new(observer, self, timeout_ms, scheduler.clone()).subscription()
        }))
    }
    
    fun retry(self, count: i32) -> Self {
        Self::new(Box::new(move |observer| {
            RetryObserver::new(observer, self, count).subscription()
        }))
    }
    
    fun catch_error(self, error_handler: Box<dyn Fn(str) -> Self>) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(CatchErrorObserver::new(observer, error_handler.clone()))
        }))
    }
    
    // Backpressure operators
    fun sample(self, period_ms: i64, scheduler: Box<dyn Scheduler>) -> Self {
        Self::new(Box::new(move |observer| {
            SampleObserver::new(observer, self, period_ms, scheduler.clone()).subscription()
        }))
    }
    
    fun throttle_first(self, duration_ms: i64) -> Self {
        Self::new(Box::new(move |observer| {
            self.subscribe(ThrottleFirstObserver::new(observer, duration_ms))
        }))
    }
    
    fun debounce(self, duration_ms: i64, scheduler: Box<dyn Scheduler>) -> Self {
        Self::new(Box::new(move |observer| {
            DebounceObserver::new(observer, self, duration_ms, scheduler.clone()).subscription()
        }))
    }
    
    // Terminal operators
    fun subscribe_on_next(self, on_next: Box<dyn Fn(T)>) -> Subscription {
        self.subscribe(CallbackObserver::new(on_next, Box::new(|_| {}), Box::new(|| {})))
    }
    
    fun subscribe_with_callbacks(
        self, 
        on_next: Box<dyn Fn(T)>, 
        on_error: Box<dyn Fn(str)>, 
        on_completed: Box<dyn Fn()>
    ) -> Subscription {
        self.subscribe(CallbackObserver::new(on_next, on_error, on_completed))
    }
    
    fun to_vec(self) -> Vec<T> {
        let result = RefCell::new(Vec::new());
        let completed = RefCell::new(false);
        
        self.subscribe(CallbackObserver::new(
            Box::new(move |value| result.borrow_mut().push(value)),
            Box::new(|_| {}),
            Box::new(move || *completed.borrow_mut() = true)
        ));
        
        // In real implementation, this would block until completion
        result.into_inner()
    }
    
    fun count(self) -> i64 {
        let count = RefCell::new(0i64);
        
        self.subscribe(CallbackObserver::new(
            Box::new(move |_| *count.borrow_mut() += 1),
            Box::new(|_| {}),
            Box::new(|| {})
        ));
        
        *count.borrow()
    }
    
    fun reduce<R>(self, seed: R, reducer: Box<dyn Fn(R, T) -> R>) -> R {
        let accumulator = RefCell::new(seed);
        
        self.subscribe(CallbackObserver::new(
            Box::new(move |value| {
                let current = accumulator.borrow().clone();
                *accumulator.borrow_mut() = reducer(current, value);
            }),
            Box::new(|_| {}),
            Box::new(|| {})
        ));
        
        accumulator.into_inner()
    }
}

// Subject implementations
struct BehaviorSubject<T> {
    observers: RefCell<Vec<Box<dyn Observer<T>>>>,
    current_value: RefCell<Option<T>>,
    completed: RefCell<bool>,
    error: RefCell<Option<str>>,
}

impl<T: Clone> BehaviorSubject<T> {
    fun new(initial_value: T) -> Self {
        Self {
            observers: RefCell::new(Vec::new()),
            current_value: RefCell::new(Some(initial_value)),
            completed: RefCell::new(false),
            error: RefCell::new(None),
        }
    }
    
    fun value(self) -> Option<T> {
        self.current_value.borrow().clone()
    }
}

impl<T: Clone> Observable<T> for BehaviorSubject<T> {
    fun subscribe(self, observer: Observer<T>) -> Subscription {
        // Send current value if available
        if let Some(ref current) = *self.current_value.borrow() {
            observer.on_next(current.clone());
        }
        
        // Check if already completed or errored
        if *self.completed.borrow() {
            observer.on_completed();
            return EmptySubscription::new();
        }
        
        if let Some(ref error) = *self.error.borrow() {
            observer.on_error(error.clone());
            return EmptySubscription::new();
        }
        
        // Add to observers list
        self.observers.borrow_mut().push(Box::new(observer));
        
        // Return subscription that removes observer when unsubscribed
        SubjectSubscription::new(self.observers.clone(), self.observers.borrow().len() - 1)
    }
}

impl<T: Clone> Observer<T> for BehaviorSubject<T> {
    fun on_next(mut self, value: T) {
        if *self.completed.borrow() || self.error.borrow().is_some() {
            return;
        }
        
        *self.current_value.borrow_mut() = Some(value.clone());
        
        for observer in self.observers.borrow().iter() {
            observer.on_next(value.clone());
        }
    }
    
    fun on_error(mut self, error: str) {
        if *self.completed.borrow() || self.error.borrow().is_some() {
            return;
        }
        
        *self.error.borrow_mut() = Some(error.clone());
        
        for observer in self.observers.borrow().iter() {
            observer.on_error(error.clone());
        }
        
        self.observers.borrow_mut().clear();
    }
    
    fun on_completed(mut self) {
        if *self.completed.borrow() || self.error.borrow().is_some() {
            return;
        }
        
        *self.completed.borrow_mut() = true;
        
        for observer in self.observers.borrow().iter() {
            observer.on_completed();
        }
        
        self.observers.borrow_mut().clear();
    }
}

impl<T> Subject<T> for BehaviorSubject<T> {
    fun has_observers(self) -> bool {
        !self.observers.borrow().is_empty()
    }
}

// PublishSubject implementation
struct PublishSubject<T> {
    observers: RefCell<Vec<Box<dyn Observer<T>>>>,
    completed: RefCell<bool>,
    error: RefCell<Option<str>>,
}

impl<T> PublishSubject<T> {
    fun new() -> Self {
        Self {
            observers: RefCell::new(Vec::new()),
            completed: RefCell::new(false),
            error: RefCell::new(None),
        }
    }
}

impl<T: Clone> Observable<T> for PublishSubject<T> {
    fun subscribe(self, observer: Observer<T>) -> Subscription {
        // Check if already completed or errored
        if *self.completed.borrow() {
            observer.on_completed();
            return EmptySubscription::new();
        }
        
        if let Some(ref error) = *self.error.borrow() {
            observer.on_error(error.clone());
            return EmptySubscription::new();
        }
        
        // Add to observers list
        self.observers.borrow_mut().push(Box::new(observer));
        
        SubjectSubscription::new(self.observers.clone(), self.observers.borrow().len() - 1)
    }
}

impl<T: Clone> Observer<T> for PublishSubject<T> {
    fun on_next(mut self, value: T) {
        if *self.completed.borrow() || self.error.borrow().is_some() {
            return;
        }
        
        for observer in self.observers.borrow().iter() {
            observer.on_next(value.clone());
        }
    }
    
    fun on_error(mut self, error: str) {
        if *self.completed.borrow() || self.error.borrow().is_some() {
            return;
        }
        
        *self.error.borrow_mut() = Some(error.clone());
        
        for observer in self.observers.borrow().iter() {
            observer.on_error(error.clone());
        }
        
        self.observers.borrow_mut().clear();
    }
    
    fun on_completed(mut self) {
        if *self.completed.borrow() || self.error.borrow().is_some() {
            return;
        }
        
        *self.completed.borrow_mut() = true;
        
        for observer in self.observers.borrow().iter() {
            observer.on_completed();
        }
        
        self.observers.borrow_mut().clear();
    }
}

impl<T> Subject<T> for PublishSubject<T> {
    fun has_observers(self) -> bool {
        !self.observers.borrow().is_empty()
    }
}

// Flow implementation
struct SimpleFlow<T> {
    source: Box<dyn Fn(FlowCollector<T>)>,
}

impl<T> SimpleFlow<T> {
    fun new(source: Box<dyn Fn(FlowCollector<T>)>) -> Self {
        Self { source }
    }
    
    fun from_iter(iter: Vec<T>) -> Self {
        Self::new(Box::new(move |collector| {
            for value in iter {
                collector.emit(value);
            }
            collector.complete();
        }))
    }
    
    fun empty() -> Self {
        Self::new(Box::new(|collector| {
            collector.complete();
        }))
    }
    
    fun error(error: str) -> Self {
        Self::new(Box::new(move |collector| {
            collector.emit_error(error);
        }))
    }
    
    // Flow operators
    fun map<U>(self, mapper: Box<dyn Fn(T) -> U>) -> SimpleFlow<U> {
        SimpleFlow::new(Box::new(move |collector| {
            let mapped_collector = MappedFlowCollector::new(collector, mapper.clone());
            (self.source)(mapped_collector);
        }))
    }
    
    fun filter(self, predicate: Box<dyn Fn(&T) -> bool>) -> Self {
        Self::new(Box::new(move |collector| {
            let filtered_collector = FilteredFlowCollector::new(collector, predicate.clone());
            (self.source)(filtered_collector);
        }))
    }
    
    fun take(self, count: i64) -> Self {
        Self::new(Box::new(move |collector| {
            let take_collector = TakeFlowCollector::new(collector, count);
            (self.source)(take_collector);
        }))
    }
    
    // Convert to Observable (hot)
    fun to_observable(self) -> SimpleObservable<T> {
        SimpleObservable::new(Box::new(move |observer| {
            let flow_collector = ObservableFlowCollector::new(observer);
            (self.source)(flow_collector.clone());
            flow_collector.subscription()
        }))
    }
}

impl<T> Flow<T> for SimpleFlow<T> {
    fun collect(self, collector: FlowCollector<T>) {
        (self.source)(collector);
    }
}

// Scheduler implementations
struct ImmediateScheduler;

impl ImmediateScheduler {
    fun new() -> Self {
        Self
    }
}

impl Scheduler for ImmediateScheduler {
    fun schedule(self, action: Box<dyn Fn()>) {
        action();
    }
    
    fun schedule_delayed(self, action: Box<dyn Fn()>, delay_ms: i64) {
        // In real implementation, this would use a timer
        std::thread::sleep(std::time::Duration::from_millis(delay_ms as u64));
        action();
    }
    
    fun schedule_periodic(self, action: Box<dyn Fn()>, initial_delay_ms: i64, period_ms: i64) -> Subscription {
        // In real implementation, this would create a background thread
        // For now, return empty subscription
        EmptySubscription::new()
    }
}

struct ThreadPoolScheduler {
    thread_count: i32,
}

impl ThreadPoolScheduler {
    fun new(thread_count: i32) -> Self {
        Self { thread_count }
    }
}

impl Scheduler for ThreadPoolScheduler {
    fun schedule(self, action: Box<dyn Fn()>) {
        // In real implementation, this would dispatch to thread pool
        std::thread::spawn(move || action());
    }
    
    fun schedule_delayed(self, action: Box<dyn Fn()>, delay_ms: i64) {
        std::thread::spawn(move || {
            std::thread::sleep(std::time::Duration::from_millis(delay_ms as u64));
            action();
        });
    }
    
    fun schedule_periodic(self, action: Box<dyn Fn()>, initial_delay_ms: i64, period_ms: i64) -> Subscription {
        // Create periodic timer
        let cancel_flag = Arc::new(AtomicBool::new(false));
        let cancel_flag_clone = cancel_flag.clone();
        
        std::thread::spawn(move || {
            std::thread::sleep(std::time::Duration::from_millis(initial_delay_ms as u64));
            
            while !cancel_flag_clone.load(std::sync::atomic::Ordering::SeqCst) {
                action();
                std::thread::sleep(std::time::Duration::from_millis(period_ms as u64));
            }
        });
        
        CancelSubscription::new(cancel_flag)
    }
}

// Subscription implementations
struct EmptySubscription {
    unsubscribed: RefCell<bool>,
}

impl EmptySubscription {
    fun new() -> Self {
        Self {
            unsubscribed: RefCell::new(false),
        }
    }
}

impl Subscription for EmptySubscription {
    fun unsubscribe(mut self) {
        *self.unsubscribed.borrow_mut() = true;
    }
    
    fun is_unsubscribed(self) -> bool {
        *self.unsubscribed.borrow()
    }
}

struct CompositeSubscription {
    subscriptions: RefCell<Vec<Box<dyn Subscription>>>,
    unsubscribed: RefCell<bool>,
}

impl CompositeSubscription {
    fun new() -> Self {
        Self {
            subscriptions: RefCell::new(Vec::new()),
            unsubscribed: RefCell::new(false),
        }
    }
    
    fun from_vec(subscriptions: Vec<Box<dyn Subscription>>) -> Self {
        Self {
            subscriptions: RefCell::new(subscriptions),
            unsubscribed: RefCell::new(false),
        }
    }
    
    fun add(mut self, subscription: Box<dyn Subscription>) {
        if *self.unsubscribed.borrow() {
            subscription.unsubscribe();
        } else {
            self.subscriptions.borrow_mut().push(subscription);
        }
    }
    
    fun remove(mut self, subscription: Box<dyn Subscription>) {
        if let Some(pos) = self.subscriptions.borrow().iter().position(|s| {
            // In real implementation, would compare subscription identity
            false
        }) {
            self.subscriptions.borrow_mut().remove(pos);
        }
    }
    
    fun clear(mut self) {
        for subscription in self.subscriptions.borrow_mut().drain(..) {
            subscription.unsubscribe();
        }
    }
}

impl Subscription for CompositeSubscription {
    fun unsubscribe(mut self) {
        if !*self.unsubscribed.borrow() {
            *self.unsubscribed.borrow_mut() = true;
            self.clear();
        }
    }
    
    fun is_unsubscribed(self) -> bool {
        *self.unsubscribed.borrow()
    }
}

// Helper observer implementations
struct CallbackObserver<T> {
    on_next: Box<dyn Fn(T)>,
    on_error: Box<dyn Fn(str)>,
    on_completed: Box<dyn Fn()>,
}

impl<T> CallbackObserver<T> {
    fun new(
        on_next: Box<dyn Fn(T)>, 
        on_error: Box<dyn Fn(str)>, 
        on_completed: Box<dyn Fn()>
    ) -> Self {
        Self { on_next, on_error, on_completed }
    }
}

impl<T> Observer<T> for CallbackObserver<T> {
    fun on_next(mut self, value: T) {
        (self.on_next)(value);
    }
    
    fun on_error(mut self, error: str) {
        (self.on_error)(error);
    }
    
    fun on_completed(mut self) {
        (self.on_completed)();
    }
}

// More observer implementations would go here...
// For brevity, showing the main structure and key components

// Reactive Extensions convenience functions
struct Rx;

impl Rx {
    fun just<T>(value: T) -> SimpleObservable<T> {
        SimpleObservable::just(value)
    }
    
    fun from<T>(iter: Vec<T>) -> SimpleObservable<T> {
        SimpleObservable::from_iter(iter)
    }
    
    fun empty<T>() -> SimpleObservable<T> {
        SimpleObservable::empty()
    }
    
    fun error<T>(error: str) -> SimpleObservable<T> {
        SimpleObservable::error(error)
    }
    
    fun interval(period_ms: i64) -> SimpleObservable<i64> {
        SimpleObservable::interval(period_ms, Box::new(ImmediateScheduler::new()))
    }
    
    fun timer(delay_ms: i64) -> SimpleObservable<i64> {
        SimpleObservable::timer(delay_ms, Box::new(ImmediateScheduler::new()))
    }
    
    fun merge<T>(observables: Vec<SimpleObservable<T>>) -> SimpleObservable<T> {
        let mut result = SimpleObservable::empty();
        for observable in observables {
            result = result.merge(observable);
        }
        result
    }
    
    fun behavior_subject<T>(initial_value: T) -> BehaviorSubject<T> {
        BehaviorSubject::new(initial_value)
    }
    
    fun publish_subject<T>() -> PublishSubject<T> {
        PublishSubject::new()
    }
    
    fun flow_of<T>(values: Vec<T>) -> SimpleFlow<T> {
        SimpleFlow::from_iter(values)
    }
}

// Placeholder implementations for complex operators
struct MapObserver<T, U> { /* Implementation */ }
struct FilterObserver<T> { /* Implementation */ }
struct TakeObserver<T> { /* Implementation */ }
struct SkipObserver<T> { /* Implementation */ }
struct FlatMapObserver<T, U> { /* Implementation */ }
struct DistinctUntilChangedObserver<T> { /* Implementation */ }
struct LastObserver<T> { /* Implementation */ }
struct CombineLatestObserver<T, U, R> { /* Implementation */ }
struct ZipObserver<T, U, R> { /* Implementation */ }
struct DelayObserver<T> { /* Implementation */ }
struct TimeoutObserver<T> { /* Implementation */ }
struct RetryObserver<T> { /* Implementation */ }
struct CatchErrorObserver<T> { /* Implementation */ }
struct SampleObserver<T> { /* Implementation */ }
struct ThrottleFirstObserver<T> { /* Implementation */ }
struct DebounceObserver<T> { /* Implementation */ }
struct SubjectSubscription { /* Implementation */ }
struct MappedFlowCollector<T, U> { /* Implementation */ }
struct FilteredFlowCollector<T> { /* Implementation */ }
struct TakeFlowCollector<T> { /* Implementation */ }
struct ObservableFlowCollector<T> { /* Implementation */ }
struct CancelSubscription { /* Implementation */ }

// Additional reactive utilities for seen language integration
struct SeenReactiveRuntime {
    default_scheduler: Box<dyn Scheduler>,
    computation_scheduler: Box<dyn Scheduler>,
    io_scheduler: Box<dyn Scheduler>,
}

impl SeenReactiveRuntime {
    fun new() -> Self {
        Self {
            default_scheduler: Box::new(ImmediateScheduler::new()),
            computation_scheduler: Box::new(ThreadPoolScheduler::new(4)),
            io_scheduler: Box::new(ThreadPoolScheduler::new(8)),
        }
    }
    
    fun default_scheduler(self) -> Box<dyn Scheduler> {
        self.default_scheduler
    }
    
    fun computation_scheduler(self) -> Box<dyn Scheduler> {
        self.computation_scheduler
    }
    
    fun io_scheduler(self) -> Box<dyn Scheduler> {
        self.io_scheduler
    }
    
    // Integration with Seen language features
    fun observable_from_channel<T>(receiver: Receiver<T>) -> SimpleObservable<T> {
        SimpleObservable::create(Box::new(move |emitter| {
            loop {
                match receiver.try_recv() {
                    Ok(value) => emitter.emit(value),
                    Err(_) => break,
                }
            }
            emitter.complete();
        }))
    }
    
    fun flow_from_async_generator<T>(generator: AsyncGenerator<T>) -> SimpleFlow<T> {
        SimpleFlow::new(Box::new(move |collector| {
            // Would integrate with Seen's async/await system
            // For now, placeholder implementation
        }))
    }
}

// Global runtime instance
static REACTIVE_RUNTIME: SeenReactiveRuntime = SeenReactiveRuntime::new();

// Convenience functions for global access
fun rx_runtime() -> &'static SeenReactiveRuntime {
    &REACTIVE_RUNTIME
}

// Main reactive programming API entry points
fun observable<T>() -> ObservableBuilder<T> {
    ObservableBuilder::new()
}

fun flow<T>() -> FlowBuilder<T> {
    FlowBuilder::new()
}

fun subject<T>() -> SubjectBuilder<T> {
    SubjectBuilder::new()
}

// Builder patterns for fluent API
struct ObservableBuilder<T>;
struct FlowBuilder<T>;
struct SubjectBuilder<T>;

impl<T> ObservableBuilder<T> {
    fun new() -> Self { Self }
    
    fun just(self, value: T) -> SimpleObservable<T> {
        Rx::just(value)
    }
    
    fun from(self, values: Vec<T>) -> SimpleObservable<T> {
        Rx::from(values)
    }
    
    fun empty(self) -> SimpleObservable<T> {
        Rx::empty()
    }
    
    fun error(self, error: str) -> SimpleObservable<T> {
        Rx::error(error)
    }
}

impl<T> FlowBuilder<T> {
    fun new() -> Self { Self }
    
    fun of(self, values: Vec<T>) -> SimpleFlow<T> {
        Rx::flow_of(values)
    }
    
    fun empty(self) -> SimpleFlow<T> {
        SimpleFlow::empty()
    }
}

impl<T> SubjectBuilder<T> {
    fun new() -> Self { Self }
    
    fun behavior(self, initial_value: T) -> BehaviorSubject<T> {
        Rx::behavior_subject(initial_value)
    }
    
    fun publish(self) -> PublishSubject<T> {
        Rx::publish_subject()
    }
}