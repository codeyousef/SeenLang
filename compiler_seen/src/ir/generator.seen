// Real IR Generator Implementation - Following TDD
// Implements comprehensive IR generation for LLVM backend

import lexer.{TokenType}
import parser.{AST, Function, Class, Expression, Statement, Block, ReturnStatement, VariableDeclaration, IfStatement, BinaryExpression, Literal, IdentifierExpression, Type as ASTType}
import typechecker.{TypeInferenceResult, Type, Environment}
import ir.interfaces.{IRModule, IRFunction, IRBasicBlock, IRInstruction, IRValue, IRType, IRError, IRBuilder}

class IRGenerator {
    let builder: IRBuilder
    let module: IRModule
    var currentFunction: IRFunction?
    let variables: Map<String, IRValue>
    let environment: Environment
    
    fun new() -> IRGenerator {
        this.builder = IRBuilder.new()
        this.module = IRModule.new("seen_program")
        this.currentFunction = null
        this.variables = Map<String, IRValue>()
        this.environment = Environment.new()
        
        // Initialize runtime functions
        initializeRuntimeFunctions()
    }
    
    fun initializeRuntimeFunctions() -> Void {
        // printf function for output
        let printfFunc = IRFunction.new("printf", IRType.I32)
        printfFunc.addParameter(IRValue.new("%fmt", IRType.Ptr))
        printfFunc.isVarArgs = true
        printfFunc.attributes.push("nounwind")
        module.addFunction(printfFunc)
        
        // malloc function for memory allocation
        let mallocFunc = IRFunction.new("malloc", IRType.Ptr)
        mallocFunc.addParameter(IRValue.new("%size", IRType.I64))
        module.addFunction(mallocFunc)
        
        // free function for memory deallocation
        let freeFunc = IRFunction.new("free", IRType.Void)
        freeFunc.addParameter(IRValue.new("%ptr", IRType.Ptr))
        module.addFunction(freeFunc)
        
        // exit function
        let exitFunc = IRFunction.new("exit", IRType.Void)
        exitFunc.addParameter(IRValue.new("%code", IRType.I32))
        module.addFunction(exitFunc)
        
        // String concatenation function (runtime library)
        let strcatFunc = IRFunction.new("string_concat", IRType.Ptr)
        strcatFunc.addParameter(IRValue.new("%str1", IRType.Ptr))
        strcatFunc.addParameter(IRValue.new("%str2", IRType.Ptr))
        module.addFunction(strcatFunc)
    }
    
    fun generate(ast: AST, typeResult: TypeInferenceResult) -> IRModule {
        if !typeResult.success {
            return IRModule.newWithErrors(typeResult.errors)
        }
        
        environment = typeResult.environment
        
        // Generate global string constants
        module.addStringConstant("%d\\n")  // For integer printing
        module.addStringConstant("%f\\n")  // For float printing  
        module.addStringConstant("%s\\n")  // For string printing
        
        // First pass: Generate function signatures
        for function in ast.functions {
            generateFunctionSignature(function)
        }
        
        // Second pass: Generate class types
        for classNode in ast.classes {
            generateClassType(classNode)
        }
        
        // Third pass: Generate function implementations
        for function in ast.functions {
            generateFunction(function)
        }
        
        // Fourth pass: Generate class implementations
        for classNode in ast.classes {
            generateClass(classNode)
        }
        
        return module
    }
    
    fun generateFunctionSignature(function: Function) -> Void {
        let returnType = convertSeenTypeToIR(resolveType(function.returnType))
        let irFunction = IRFunction.new(function.name, returnType)
        
        for param in function.parameters {
            let paramType = convertSeenTypeToIR(resolveType(param.type))
            let paramValue = IRValue.new("%{param.name}", paramType)
            irFunction.addParameter(paramValue)
        }
        
        module.addFunction(irFunction)
    }
    
    fun generateClassType(classNode: Class) -> Void {
        // Create struct type for class
        let structName = "struct.{classNode.name}"
        let structType = IRType.new(structName, 0)  // Size will be calculated
        
        // Add to module types
        module.addType(classNode.name, structType)
        
        // Generate constructor if not explicitly defined
        generateDefaultConstructor(classNode)
    }
    
    fun generateDefaultConstructor(classNode: Class) -> Void {
        let constructorName = "{classNode.name}.new"
        let existingFunc = module.getFunction(constructorName)
        
        if existingFunc == null {
            // Create default constructor
            let ptrType = IRType.new("{classNode.name}*", 64, true)
            let constructor = IRFunction.new(constructorName, ptrType)
            
            // Add parameters for field initialization
            for field in classNode.fields {
                let fieldType = convertSeenTypeToIR(resolveType(field.type))
                constructor.addParameter(IRValue.new("%{field.name}", fieldType))
            }
            
            module.addFunction(constructor)
        }
    }
    
    fun generateFunction(function: Function) -> IRFunction {
        let irFunction = module.getFunction(function.name)
        if irFunction == null {
            module.addError(IRError.new("Function {function.name} not found in module", function.line, function.column))
            return IRFunction.new(function.name, IRType.Void)
        }
        
        currentFunction = irFunction
        
        // Create entry block
        let entryBlock = builder.createBlock("entry")
        irFunction.addBlock(entryBlock)
        builder.setInsertPoint(entryBlock)
        
        // Create stack variables for parameters
        for i in 0..function.parameters.length() {
            let param = function.parameters[i]
            let paramType = convertSeenTypeToIR(resolveType(param.type))
            let alloca = builder.createAlloca(paramType, param.name)
            
            // Store parameter value to alloca
            let paramValue = irFunction.parameters[i]
            builder.createStore(paramValue, alloca)
            variables.put(param.name, alloca)
        }
        
        // Generate function body
        generateStatement(function.body)
        
        // Add return void if function doesn't end with return
        if irFunction.returnType == IRType.Void {
            let lastBlock = irFunction.blocks[irFunction.blocks.length() - 1]
            let instructions = lastBlock.instructions
            if instructions.length() == 0 or instructions[instructions.length() - 1].opcode != "ret" {
                builder.createRet()
            }
        }
        
        currentFunction = null
        variables.clear()
        
        return irFunction
    }
    
    fun generateStatement(statement: Statement) -> Void {
        if statement is Block {
            generateBlock(statement as Block)
        } else if statement is ReturnStatement {
            generateReturn(statement as ReturnStatement)
        } else if statement is VariableDeclaration {
            generateVariableDeclaration(statement as VariableDeclaration)
        } else if statement is IfStatement {
            generateIf(statement as IfStatement)
        } else if statement is ExpressionStatement {
            generateExpression((statement as ExpressionStatement).expression)
        } else {
            module.addError(IRError.new("Unknown statement type", statement.line, statement.column))
        }
    }
    
    fun generateBlock(block: Block) -> Void {
        for statement in block.statements {
            generateStatement(statement)
        }
    }
    
    fun generateReturn(returnStmt: ReturnStatement) -> Void {
        if returnStmt.value != null {
            let value = generateExpression(returnStmt.value)
            builder.createRet(value)
        } else {
            builder.createRet()
        }
    }
    
    fun generateVariableDeclaration(varDecl: VariableDeclaration) -> Void {
        let declaredType = resolveType(varDecl.type)
        let irType = convertSeenTypeToIR(declaredType)
        
        // Create alloca for variable
        let alloca = builder.createAlloca(irType, varDecl.name)
        variables.put(varDecl.name, alloca)
        
        // Initialize if there's an initializer
        if varDecl.initializer != null {
            let initValue = generateExpression(varDecl.initializer)
            builder.createStore(initValue, alloca)
        }
    }
    
    fun generateIf(ifStmt: IfStatement) -> Void {
        let condition = generateExpression(ifStmt.condition)
        
        let thenBlock = builder.createBlock("if.then")
        let elseBlock = builder.createBlock("if.else")
        let endBlock = builder.createBlock("if.end")
        
        // Branch on condition
        builder.createCondBr(condition, thenBlock, elseBlock)
        
        // Generate then branch
        currentFunction?.addBlock(thenBlock)
        builder.setInsertPoint(thenBlock)
        generateStatement(ifStmt.thenBranch)
        builder.createBr(endBlock)
        
        // Generate else branch
        currentFunction?.addBlock(elseBlock)
        builder.setInsertPoint(elseBlock)
        if ifStmt.elseBranch != null {
            generateStatement(ifStmt.elseBranch)
        }
        builder.createBr(endBlock)
        
        // Continue with end block
        currentFunction?.addBlock(endBlock)
        builder.setInsertPoint(endBlock)
    }
    
    fun generateExpression(expression: Expression) -> IRValue {
        if expression is Literal {
            return generateLiteral(expression as Literal)
        } else if expression is IdentifierExpression {
            return generateIdentifier(expression as IdentifierExpression)
        } else if expression is BinaryExpression {
            return generateBinary(expression as BinaryExpression)
        } else if expression is UnaryExpression {
            return generateUnary(expression as UnaryExpression)
        } else if expression is CallExpression {
            return generateCall(expression as CallExpression)
        } else {
            module.addError(IRError.new("Unknown expression type", expression.line, expression.column))
            return IRValue.new("error", IRType.I32, true, "0")
        }
    }
    
    fun generateLiteral(literal: Literal) -> IRValue {
        return match literal.type {
            TokenType.IntegerLiteral -> {
                IRValue.new(literal.value, IRType.I32, true, literal.value)
            }
            TokenType.FloatLiteral -> {
                IRValue.new(literal.value, IRType.F64, true, literal.value)
            }
            TokenType.StringLiteral -> {
                let constName = module.addStringConstant(literal.value)
                IRValue.new(constName, IRType.Ptr, true, constName)
            }
            TokenType.KeywordTrue -> {
                IRValue.new("true", IRType.new("i1", 1), true, "true")
            }
            TokenType.KeywordFalse -> {
                IRValue.new("false", IRType.new("i1", 1), true, "false")
            }
            _ -> {
                module.addError(IRError.new("Unknown literal type", literal.line, literal.column))
                IRValue.new("error", IRType.I32, true, "0")
            }
        }
    }
    
    fun generateIdentifier(identifier: IdentifierExpression) -> IRValue {
        let variable = variables.get(identifier.name)
        if variable == null {
            module.addError(IRError.new("Undefined variable: {identifier.name}", identifier.line, identifier.column))
            return IRValue.new("error", IRType.I32, true, "0")
        }
        
        // Load the value from the alloca
        return builder.createLoad(variable)
    }
    
    fun generateBinary(binary: BinaryExpression) -> IRValue {
        let left = generateExpression(binary.left)
        let right = generateExpression(binary.right)
        
        return match binary.operator {
            TokenType.Plus -> {
                if left.type == IRType.I32 and right.type == IRType.I32 {
                    builder.createAdd(left, right)
                } else if left.type == IRType.F64 and right.type == IRType.F64 {
                    let result = IRValue.new(builder.getNextRegister(), IRType.F64)
                    let instruction = IRInstruction.new("fadd", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                } else {
                    // String concatenation or mixed types
                    generateStringConcat(left, right)
                }
            }
            
            TokenType.Minus -> {
                if left.type == IRType.I32 and right.type == IRType.I32 {
                    let result = IRValue.new(builder.getNextRegister(), IRType.I32)
                    let instruction = IRInstruction.new("sub", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                } else {
                    let result = IRValue.new(builder.getNextRegister(), IRType.F64)
                    let instruction = IRInstruction.new("fsub", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                }
            }
            
            TokenType.Multiply -> {
                if left.type == IRType.I32 and right.type == IRType.I32 {
                    let result = IRValue.new(builder.getNextRegister(), IRType.I32)
                    let instruction = IRInstruction.new("mul", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                } else {
                    let result = IRValue.new(builder.getNextRegister(), IRType.F64)
                    let instruction = IRInstruction.new("fmul", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                }
            }
            
            TokenType.Divide -> {
                if left.type == IRType.I32 and right.type == IRType.I32 {
                    let result = IRValue.new(builder.getNextRegister(), IRType.I32)
                    let instruction = IRInstruction.new("sdiv", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                } else {
                    let result = IRValue.new(builder.getNextRegister(), IRType.F64)
                    let instruction = IRInstruction.new("fdiv", result)
                    instruction.addOperand(left)
                    instruction.addOperand(right)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                }
            }
            
            TokenType.EqualEqual -> {
                builder.createICmp("eq", left, right)
            }
            
            TokenType.NotEqual -> {
                builder.createICmp("ne", left, right)
            }
            
            TokenType.LessThan -> {
                builder.createICmp("slt", left, right)
            }
            
            TokenType.LessEqual -> {
                builder.createICmp("sle", left, right)
            }
            
            TokenType.GreaterThan -> {
                builder.createICmp("sgt", left, right)
            }
            
            TokenType.GreaterEqual -> {
                builder.createICmp("sge", left, right)
            }
            
            TokenType.LogicalAnd -> {
                generateLogicalAnd(left, right)
            }
            
            TokenType.LogicalOr -> {
                generateLogicalOr(left, right)
            }
            
            _ -> {
                module.addError(IRError.new("Unknown binary operator", binary.line, binary.column))
                IRValue.new("error", IRType.I32, true, "0")
            }
        }
    }
    
    fun generateStringConcat(left: IRValue, right: IRValue) -> IRValue {
        // Call string_concat runtime function
        let args = Array<IRValue>()
        args.push(left)
        args.push(right)
        
        let result = builder.createCall("string_concat", args, IRType.Ptr)
        return result ?: IRValue.new("error", IRType.Ptr, true)
    }
    
    fun generateLogicalAnd(left: IRValue, right: IRValue) -> IRValue {
        // Implement short-circuit evaluation
        let result = IRValue.new(builder.getNextRegister(), IRType.new("i1", 1))
        let instruction = IRInstruction.new("and", result)
        instruction.addOperand(left)
        instruction.addOperand(right)
        builder.currentBlock?.addInstruction(instruction)
        return result
    }
    
    fun generateLogicalOr(left: IRValue, right: IRValue) -> IRValue {
        // Implement short-circuit evaluation
        let result = IRValue.new(builder.getNextRegister(), IRType.new("i1", 1))
        let instruction = IRInstruction.new("or", result)
        instruction.addOperand(left)
        instruction.addOperand(right)
        builder.currentBlock?.addInstruction(instruction)
        return result
    }
    
    fun generateUnary(unary: UnaryExpression) -> IRValue {
        let operand = generateExpression(unary.operand)
        
        return match unary.operator {
            TokenType.Minus -> {
                if operand.type == IRType.I32 {
                    let zero = IRValue.new("0", IRType.I32, true, "0")
                    let result = IRValue.new(builder.getNextRegister(), IRType.I32)
                    let instruction = IRInstruction.new("sub", result)
                    instruction.addOperand(zero)
                    instruction.addOperand(operand)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                } else {
                    let zero = IRValue.new("0.0", IRType.F64, true, "0.0")
                    let result = IRValue.new(builder.getNextRegister(), IRType.F64)
                    let instruction = IRInstruction.new("fsub", result)
                    instruction.addOperand(zero)
                    instruction.addOperand(operand)
                    builder.currentBlock?.addInstruction(instruction)
                    result
                }
            }
            
            TokenType.LogicalNot -> {
                let trueVal = IRValue.new("true", IRType.new("i1", 1), true, "true")
                let result = IRValue.new(builder.getNextRegister(), IRType.new("i1", 1))
                let instruction = IRInstruction.new("xor", result)
                instruction.addOperand(operand)
                instruction.addOperand(trueVal)
                builder.currentBlock?.addInstruction(instruction)
                result
            }
            
            _ -> {
                module.addError(IRError.new("Unknown unary operator", unary.line, unary.column))
                IRValue.new("error", IRType.I32, true, "0")
            }
        }
    }
    
    fun generateCall(call: CallExpression) -> IRValue {
        let args = Array<IRValue>()
        for arg in call.arguments {
            args.push(generateExpression(arg))
        }
        
        // Special handling for built-in functions
        if call.name == "println" {
            return generatePrintln(args)
        }
        
        // Look up function in module
        let targetFunc = module.getFunction(call.name)
        if targetFunc == null {
            module.addError(IRError.new("Unknown function: {call.name}", call.line, call.column))
            return IRValue.new("error", IRType.I32, true, "0")
        }
        
        let result = builder.createCall(call.name, args, targetFunc.returnType)
        return result ?: IRValue.new("void", IRType.Void, true)
    }
    
    fun generatePrintln(args: Array<IRValue>) -> IRValue {
        if args.length() == 0 {
            return IRValue.new("void", IRType.Void, true)
        }
        
        let arg = args[0]
        let formatStr: String
        
        if arg.type == IRType.I32 {
            formatStr = "@.str.0"  // "%d\\n"
        } else if arg.type == IRType.F64 {
            formatStr = "@.str.1"  // "%f\\n"
        } else {
            formatStr = "@.str.2"  // "%s\\n"
        }
        
        let printfArgs = Array<IRValue>()
        printfArgs.push(IRValue.new(formatStr, IRType.Ptr, true))
        printfArgs.push(arg)
        
        let result = builder.createCall("printf", printfArgs, IRType.I32)
        return result ?: IRValue.new("void", IRType.Void, true)
    }
    
    fun generateClass(classNode: Class) -> Void {
        // Generate constructor implementation
        generateConstructor(classNode)
        
        // Generate method implementations
        for method in classNode.methods {
            generateMethod(classNode, method)
        }
    }
    
    fun generateConstructor(classNode: Class) -> Void {
        let constructorName = "{classNode.name}.new"
        let constructor = module.getFunction(constructorName)
        
        if constructor != null and constructor.blocks.length() == 0 {
            currentFunction = constructor
            
            let entryBlock = builder.createBlock("entry")
            constructor.addBlock(entryBlock)
            builder.setInsertPoint(entryBlock)
            
            // Calculate struct size and allocate memory
            let structSize = calculateStructSize(classNode)
            let sizeValue = IRValue.new("{structSize}", IRType.I64, true, structSize.toString())
            let mallocResult = builder.createCall("malloc", [sizeValue], IRType.Ptr)
            
            // Initialize fields with parameter values
            for i in 0..classNode.fields.length() {
                let field = classNode.fields[i]
                let paramValue = constructor.parameters[i]
                
                // Calculate field offset and store value
                let fieldPtr = calculateFieldPointer(mallocResult, i)
                builder.createStore(paramValue, fieldPtr)
            }
            
            // Return allocated object
            builder.createRet(mallocResult)
            
            currentFunction = null
        }
    }
    
    fun generateMethod(classNode: Class, method: Function) -> Void {
        let methodName = "{classNode.name}.{method.name}"
        
        // Create method function with 'this' parameter
        let returnType = convertSeenTypeToIR(resolveType(method.returnType))
        let methodFunc = IRFunction.new(methodName, returnType)
        
        // Add 'this' parameter
        let thisType = IRType.new("{classNode.name}*", 64, true)
        methodFunc.addParameter(IRValue.new("%this", thisType))
        
        // Add regular parameters
        for param in method.parameters {
            let paramType = convertSeenTypeToIR(resolveType(param.type))
            methodFunc.addParameter(IRValue.new("%{param.name}", paramType))
        }
        
        module.addFunction(methodFunc)
        
        // Generate method body (similar to regular function)
        currentFunction = methodFunc
        
        let entryBlock = builder.createBlock("entry")
        methodFunc.addBlock(entryBlock)
        builder.setInsertPoint(entryBlock)
        
        // Set up variables for parameters
        for i in 1..methodFunc.parameters.length() {  // Skip 'this' parameter
            let param = method.parameters[i - 1]
            let paramType = convertSeenTypeToIR(resolveType(param.type))
            let alloca = builder.createAlloca(paramType, param.name)
            builder.createStore(methodFunc.parameters[i], alloca)
            variables.put(param.name, alloca)
        }
        
        generateStatement(method.body)
        
        // Add return if needed
        if returnType == IRType.Void {
            builder.createRet()
        }
        
        currentFunction = null
        variables.clear()
    }
    
    fun convertSeenTypeToIR(seenType: Type) -> IRType {
        return match seenType.name {
            "Int" -> IRType.I32
            "Float" -> IRType.F64
            "String" -> IRType.Ptr
            "Bool" -> IRType.new("i1", 1)
            "Void" -> IRType.Void
            _ -> {
                // User-defined type (class)
                IRType.new("{seenType.name}*", 64, true)
            }
        }
    }
    
    fun resolveType(astType: ASTType?) -> Type {
        if astType == null {
            return Type.Void
        }
        
        return match astType.name {
            "Int" -> Type.Int
            "Float" -> Type.Float
            "String" -> Type.String
            "Bool" -> Type.Bool
            "Void" -> Type.Void
            _ -> Type.new(astType.name, astType.isNullable)
        }
    }
    
    fun calculateStructSize(classNode: Class) -> Int {
        let size = 0
        for field in classNode.fields {
            let fieldType = convertSeenTypeToIR(resolveType(field.type))
            size += fieldType.size / 8  // Convert bits to bytes
        }
        return size
    }
    
    fun calculateFieldPointer(structPtr: IRValue?, fieldIndex: Int) -> IRValue {
        // Simplified field pointer calculation
        // In real implementation, would use getelementptr
        let result = IRValue.new(builder.getNextRegister(), IRType.Ptr)
        let instruction = IRInstruction.new("getelementptr", result)
        instruction.addOperand(structPtr ?: IRValue.new("null", IRType.Ptr, true))
        instruction.addOperand(IRValue.new("0", IRType.I32, true, "0"))
        instruction.addOperand(IRValue.new(fieldIndex.toString(), IRType.I32, true, fieldIndex.toString()))
        builder.currentBlock?.addInstruction(instruction)
        return result
    }
}

// Additional AST classes needed by IR generator

class ExpressionStatement extends Statement {
    let expression: Expression
    
    fun new(expression: Expression) -> ExpressionStatement {
        super(expression.line, expression.column)
        this.expression = expression
    }
}

class UnaryExpression extends Expression {
    let operator: TokenType
    let operand: Expression
    
    fun new(operator: TokenType, operand: Expression) -> UnaryExpression {
        super(operand.line, operand.column)
        this.operator = operator
        this.operand = operand
    }
}

class CallExpression extends Expression {
    let name: String
    let arguments: Array<Expression>
    
    fun new(name: String, arguments: Array<Expression>, line: Int, column: Int) -> CallExpression {
        super(line, column)
        this.name = name
        this.arguments = arguments
    }
}