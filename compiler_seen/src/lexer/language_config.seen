// Language configuration for multilingual lexing support
// Supports English and Arabic keywords with the same functionality

import std.collections.HashMap;
import "token.seen";

// Language configuration structure
struct LanguageConfig {
    language_code: str,
    keywords: HashMap<str, TokenType>,
    operators: HashMap<str, TokenType>,
}

impl LanguageConfig {
    // Create English language configuration
    fun english() -> Self {
        let mut keywords = HashMap::new();
        
        // Basic keywords
        keywords.insert("fun", TokenType::KeywordFun);
        keywords.insert("let", TokenType::KeywordLet);
        keywords.insert("mut", TokenType::KeywordMut);
        keywords.insert("if", TokenType::KeywordIf);
        keywords.insert("else", TokenType::KeywordElse);
        keywords.insert("while", TokenType::KeywordWhile);
        keywords.insert("for", TokenType::KeywordFor);
        keywords.insert("in", TokenType::KeywordIn);
        keywords.insert("return", TokenType::KeywordReturn);
        keywords.insert("break", TokenType::KeywordBreak);
        keywords.insert("continue", TokenType::KeywordContinue);
        keywords.insert("trait", TokenType::KeywordTrait);
        keywords.insert("impl", TokenType::KeywordImpl);
        keywords.insert("struct", TokenType::KeywordStruct);
        keywords.insert("enum", TokenType::KeywordEnum);
        keywords.insert("match", TokenType::KeywordMatch);
        keywords.insert("import", TokenType::KeywordImport);
        keywords.insert("export", TokenType::KeywordExport);
        keywords.insert("as", TokenType::KeywordAs);
        keywords.insert("is", TokenType::KeywordIs);
        keywords.insert("where", TokenType::KeywordWhere);
        keywords.insert("self", TokenType::KeywordSelf);
        keywords.insert("super", TokenType::KeywordSuper);
        keywords.insert("pub", TokenType::KeywordPub);
        keywords.insert("const", TokenType::KeywordConst);
        keywords.insert("static", TokenType::KeywordStatic);
        keywords.insert("async", TokenType::KeywordAsync);
        keywords.insert("await", TokenType::KeywordAwait);
        keywords.insert("true", TokenType::KeywordTrue);
        keywords.insert("false", TokenType::KeywordFalse);
        keywords.insert("null", TokenType::KeywordNull);
        keywords.insert("undefined", TokenType::KeywordUndefined);
        
        // Kotlin-inspired keywords
        keywords.insert("data", TokenType::KeywordData);
        keywords.insert("sealed", TokenType::KeywordSealed);
        keywords.insert("open", TokenType::KeywordOpen);
        keywords.insert("override", TokenType::KeywordOverride);
        keywords.insert("abstract", TokenType::KeywordAbstract);
        keywords.insert("interface", TokenType::KeywordInterface);
        keywords.insert("object", TokenType::KeywordObject);
        keywords.insert("inline", TokenType::KeywordInline);
        keywords.insert("infix", TokenType::KeywordInfix);
        keywords.insert("operator", TokenType::KeywordOperator);
        keywords.insert("suspend", TokenType::KeywordSuspend);
        keywords.insert("yield", TokenType::KeywordYield);
        
        // Reactive programming keywords
        keywords.insert("observable", TokenType::KeywordObservable);
        keywords.insert("flow", TokenType::KeywordFlow);
        keywords.insert("subscribe", TokenType::KeywordSubscribe);
        keywords.insert("emit", TokenType::KeywordEmit);
        keywords.insert("collect", TokenType::KeywordCollect);
        
        let operators = Self::create_operators();
        
        Self {
            language_code: "en",
            keywords,
            operators,
        }
    }
    
    // Create Arabic language configuration
    fun arabic() -> Self {
        let mut keywords = HashMap::new();
        
        // Basic keywords in Arabic
        keywords.insert("دالة", TokenType::KeywordDalah);           // function
        keywords.insert("اجعل", TokenType::KeywordAjel);           // let
        keywords.insert("متغير", TokenType::KeywordMotghaier);      // mut
        keywords.insert("إذا", TokenType::KeywordIdha);           // if
        keywords.insert("وإلا", TokenType::KeywordWillah);         // else
        keywords.insert("بينما", TokenType::KeywordBeynama);       // while
        keywords.insert("لكل", TokenType::KeywordLekol);          // for
        keywords.insert("في", TokenType::KeywordFi);             // in
        keywords.insert("أرجع", TokenType::KeywordArje);          // return
        keywords.insert("اكسر", TokenType::KeywordAksir);         // break
        keywords.insert("واصل", TokenType::KeywordWasil);         // continue
        keywords.insert("صفة", TokenType::KeywordSifa);           // trait
        keywords.insert("تطبيق", TokenType::KeywordTatbiq);        // impl
        keywords.insert("بنية", TokenType::KeywordBonya);         // struct
        keywords.insert("تعداد", TokenType::KeywordTaadod);        // enum
        keywords.insert("طابق", TokenType::KeywordTaybiq);        // match
        keywords.insert("استراد", TokenType::KeywordEstirad);      // import
        keywords.insert("تصدير", TokenType::KeywordTasdir);       // export
        keywords.insert("كما", TokenType::KeywordKama);           // as
        keywords.insert("صحيح", TokenType::KeywordSahih);         // true
        keywords.insert("خطأ", TokenType::KeywordKhatae);         // false
        
        // Additional Arabic keywords would map to the same TokenTypes
        // as their English equivalents for consistent functionality
        keywords.insert("بيانات", TokenType::KeywordData);         // data
        keywords.insert("مختوم", TokenType::KeywordSealed);        // sealed
        keywords.insert("مفتوح", TokenType::KeywordOpen);          // open
        keywords.insert("تجاوز", TokenType::KeywordOverride);      // override
        keywords.insert("مجرد", TokenType::KeywordAbstract);       // abstract
        keywords.insert("واجهة", TokenType::KeywordInterface);     // interface
        keywords.insert("كائن", TokenType::KeywordObject);        // object
        keywords.insert("مباشر", TokenType::KeywordInline);        // inline
        keywords.insert("وسطي", TokenType::KeywordInfix);         // infix
        keywords.insert("معامل", TokenType::KeywordOperator);      // operator
        keywords.insert("معلق", TokenType::KeywordSuspend);        // suspend
        keywords.insert("اعط", TokenType::KeywordYield);          // yield
        
        // Reactive programming in Arabic
        keywords.insert("قابل_للمراقبة", TokenType::KeywordObservable);  // observable
        keywords.insert("تدفق", TokenType::KeywordFlow);            // flow
        keywords.insert("اشترك", TokenType::KeywordSubscribe);       // subscribe
        keywords.insert("أصدر", TokenType::KeywordEmit);            // emit
        keywords.insert("اجمع", TokenType::KeywordCollect);          // collect
        
        let operators = Self::create_operators();
        
        Self {
            language_code: "ar",
            keywords,
            operators,
        }
    }
    
    // Create operator mappings (same for all languages)
    fun create_operators() -> HashMap<str, TokenType> {
        let mut operators = HashMap::new();
        
        // Basic operators
        operators.insert("+", TokenType::Plus);
        operators.insert("-", TokenType::Minus);
        operators.insert("*", TokenType::Star);
        operators.insert("/", TokenType::Slash);
        operators.insert("%", TokenType::Percent);
        operators.insert("=", TokenType::Equal);
        operators.insert("==", TokenType::EqualEqual);
        operators.insert("!=", TokenType::BangEqual);
        operators.insert("<", TokenType::Less);
        operators.insert("<=", TokenType::LessEqual);
        operators.insert(">", TokenType::Greater);
        operators.insert(">=", TokenType::GreaterEqual);
        operators.insert("!", TokenType::Bang);
        operators.insert("&", TokenType::Ampersand);
        operators.insert("&&", TokenType::AmpersandAmpersand);
        operators.insert("|", TokenType::Pipe);
        operators.insert("||", TokenType::PipePipe);
        operators.insert("^", TokenType::Caret);
        operators.insert("~", TokenType::Tilde);
        operators.insert("<<", TokenType::LeftShift);
        operators.insert(">>", TokenType::RightShift);
        
        // Assignment operators
        operators.insert("+=", TokenType::PlusEqual);
        operators.insert("-=", TokenType::MinusEqual);
        operators.insert("*=", TokenType::StarEqual);
        operators.insert("/=", TokenType::SlashEqual);
        operators.insert("%=", TokenType::PercentEqual);
        operators.insert("&=", TokenType::AmpersandEqual);
        operators.insert("|=", TokenType::PipeEqual);
        operators.insert("^=", TokenType::CaretEqual);
        operators.insert("<<=", TokenType::LeftShiftEqual);
        operators.insert(">>=", TokenType::RightShiftEqual);
        
        // Increment/Decrement
        operators.insert("++", TokenType::PlusPlus);
        operators.insert("--", TokenType::MinusMinus);
        
        // Special operators
        operators.insert("->", TokenType::Arrow);
        operators.insert("=>", TokenType::FatArrow);
        operators.insert("::", TokenType::ColonColon);
        operators.insert("..", TokenType::DotDot);
        operators.insert("...", TokenType::DotDotDot);
        operators.insert("?.", TokenType::QuestionDot);
        operators.insert("??", TokenType::QuestionQuestion);
        operators.insert("?:", TokenType::Elvis);
        operators.insert("!!", TokenType::NotNull);
        operators.insert("..=", TokenType::RangeInclusive);
        
        operators
    }
    
    // Get token type for a keyword (returns None if not a keyword)
    fun get_keyword_type(self, lexeme: str) -> Option<TokenType> {
        self.keywords.get(lexeme).copied()
    }
    
    // Get token type for an operator (returns None if not an operator)
    fun get_operator_type(self, lexeme: str) -> Option<TokenType> {
        self.operators.get(lexeme).copied()
    }
    
    // Check if identifier is a keyword in this language
    fun is_keyword(self, identifier: str) -> bool {
        self.keywords.contains_key(identifier)
    }
    
    // Check if text is an operator
    fun is_operator(self, text: str) -> bool {
        self.operators.contains_key(text)
    }
    
    // Get all keywords for this language
    fun get_all_keywords(self) -> Vec<str> {
        self.keywords.keys().collect()
    }
    
    // Get all operators
    fun get_all_operators(self) -> Vec<str> {
        self.operators.keys().collect()
    }
    
    // Convert between English and Arabic keywords (for translation)
    fun translate_keyword(from_lang: str, to_lang: str, keyword: str) -> Option<str> {
        // This would implement keyword translation between languages
        // For now, returns None - full implementation would have translation table
        None
    }
    
    // Create language config from language code
    fun from_language_code(code: str) -> Self {
        match code {
            "en" | "english" => Self::english(),
            "ar" | "arabic" => Self::arabic(),
            _ => Self::english(), // Default to English
        }
    }
    
    // Check if language supports right-to-left text
    fun is_rtl(self) -> bool {
        self.language_code == "ar"
    }
    
    // Get language display name
    fun display_name(self) -> str {
        match self.language_code.as_str() {
            "en" => "English",
            "ar" => "العربية",
            _ => "Unknown",
        }
    }
    
    // Get language direction for IDE support
    fun text_direction(self) -> str {
        if self.is_rtl() { "rtl" } else { "ltr" }
    }
}