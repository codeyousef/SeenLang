// Token definitions for the Seen language
// Ported from Rust implementation with all token types

import std.string.String;

// Token structure representing a lexical unit
struct Token {
    token_type: TokenType,
    lexeme: str,
    line: i32,
    column: i32,
}

// All possible token types in the Seen language
enum TokenType {
    // Special tokens
    EOF,
    
    // Literals
    Identifier,
    IntegerLiteral,
    FloatLiteral,  
    StringLiteral,
    CharLiteral,
    BooleanLiteral,
    
    // Keywords (English)
    KeywordFun,        // fun
    KeywordLet,        // let
    KeywordMut,        // mut
    KeywordIf,         // if
    KeywordElse,       // else
    KeywordWhile,      // while
    KeywordFor,        // for
    KeywordIn,         // in
    KeywordReturn,     // return
    KeywordBreak,      // break
    KeywordContinue,   // continue
    KeywordTrait,      // trait
    KeywordImpl,       // impl
    KeywordStruct,     // struct
    KeywordEnum,       // enum
    KeywordMatch,      // match
    KeywordImport,     // import
    KeywordExport,     // export
    KeywordAs,         // as
    KeywordIs,         // is
    KeywordWhere,      // where
    KeywordSelf,       // self
    KeywordSuper,      // super
    KeywordPub,        // pub
    KeywordConst,      // const
    KeywordStatic,     // static
    KeywordAsync,      // async
    KeywordAwait,      // await
    KeywordTrue,       // true
    KeywordFalse,      // false
    KeywordNull,       // null
    KeywordUndefined,  // undefined
    
    // Kotlin-inspired keywords
    KeywordData,       // data (for data classes)
    KeywordSealed,     // sealed (for sealed classes)
    KeywordOpen,       // open (for inheritance)
    KeywordOverride,   // override
    KeywordAbstract,   // abstract
    KeywordInterface,  // interface
    KeywordObject,     // object (for singletons)
    KeywordInline,     // inline (for inline functions)
    KeywordInfix,      // infix (for infix functions)
    KeywordOperator,   // operator (for operator overloading)
    KeywordSuspend,    // suspend (for coroutines)
    KeywordYield,      // yield (for generators)
    
    // Reactive programming keywords
    KeywordObservable, // observable
    KeywordFlow,       // flow
    KeywordSubscribe,  // subscribe
    KeywordEmit,       // emit
    KeywordCollect,    // collect
    
    // Arabic keywords (same functionality, different language)
    KeywordDalah,      // دالة (function)
    KeywordAjel,       // اجعل (let)
    KeywordMotghaier,  // متغير (mut)
    KeywordIdha,       // إذا (if)
    KeywordWillah,     // وإلا (else)
    KeywordBeynama,    // بينما (while)
    KeywordLekol,      // لكل (for)
    KeywordFi,         // في (in)
    KeywordArje,       // أرجع (return)
    KeywordAksir,      // اكسر (break)
    KeywordWasil,      // واصل (continue)
    KeywordSifa,       // صفة (trait)
    KeywordTatbiq,     // تطبيق (impl)
    KeywordBonya,      // بنية (struct)
    KeywordTaadod,     // تعداد (enum)
    KeywordTaybiq,     // تطبيق (match)
    KeywordEstirad,    // استراد (import)
    KeywordTasdir,     // تصدير (export)
    KeywordKama,       // كما (as)
    KeywordSahih,      // صحيح (true)
    KeywordKhatae,     // خطأ (false)
    
    // Operators
    Plus,              // +
    Minus,             // -
    Star,              // *
    Slash,             // /
    Percent,           // %
    Equal,             // =
    EqualEqual,        // ==
    BangEqual,         // !=
    Less,              // <
    LessEqual,         // <=
    Greater,           // >
    GreaterEqual,      // >=
    Bang,              // !
    Ampersand,         // &
    AmpersandAmpersand,// &&
    Pipe,              // |
    PipePipe,          // ||
    Caret,             // ^
    Tilde,             // ~
    LeftShift,         // <<
    RightShift,        // >>
    
    // Assignment operators
    PlusEqual,         // +=
    MinusEqual,        // -=
    StarEqual,         // *=
    SlashEqual,        // /=
    PercentEqual,      // %=
    AmpersandEqual,    // &=
    PipeEqual,         // |=
    CaretEqual,        // ^=
    LeftShiftEqual,    // <<=
    RightShiftEqual,   // >>=
    
    // Increment/Decrement
    PlusPlus,          // ++
    MinusMinus,        // --
    
    // Punctuation
    LeftParen,         // (
    RightParen,        // )
    LeftBrace,         // {
    RightBrace,        // }
    LeftBracket,       // [
    RightBracket,      // ]
    Comma,             // ,
    Semicolon,         // ;
    Colon,             // :
    ColonColon,        // ::
    Dot,               // .
    DotDot,            // ..
    DotDotDot,         // ...
    Arrow,             // ->
    FatArrow,          // =>
    Question,          // ?
    QuestionDot,       // ?.
    QuestionQuestion,  // ??
    At,                // @
    Hash,              // #
    Dollar,            // $
    
    // Special operators
    Elvis,             // ?: (Elvis operator from Kotlin)
    SafeCall,          // ?. (Safe call operator)
    NotNull,           // !! (Not-null assertion)
    Range,             // .. (Range operator)
    RangeInclusive,    // ..= (Inclusive range)
    
    // Comments (for documentation)
    LineComment,       // // comment
    BlockComment,      // /* comment */
    DocComment,        // /// documentation
    
    // Whitespace (usually ignored but sometimes significant)
    Whitespace,
    Newline,
    
    // Error token for lexical errors
    Error,
}

impl TokenType {
    // Check if token is a keyword
    fun is_keyword(self) -> bool {
        match self {
            TokenType::KeywordFun | TokenType::KeywordLet | TokenType::KeywordMut |
            TokenType::KeywordIf | TokenType::KeywordElse | TokenType::KeywordWhile |
            TokenType::KeywordFor | TokenType::KeywordIn | TokenType::KeywordReturn |
            TokenType::KeywordBreak | TokenType::KeywordContinue | TokenType::KeywordTrait |
            TokenType::KeywordImpl | TokenType::KeywordStruct | TokenType::KeywordEnum |
            TokenType::KeywordMatch | TokenType::KeywordImport | TokenType::KeywordExport |
            TokenType::KeywordAs | TokenType::KeywordIs | TokenType::KeywordWhere |
            TokenType::KeywordSelf | TokenType::KeywordSuper | TokenType::KeywordPub |
            TokenType::KeywordConst | TokenType::KeywordStatic | TokenType::KeywordAsync |
            TokenType::KeywordAwait | TokenType::KeywordTrue | TokenType::KeywordFalse |
            TokenType::KeywordNull | TokenType::KeywordUndefined |
            
            // Kotlin-inspired keywords
            TokenType::KeywordData | TokenType::KeywordSealed | TokenType::KeywordOpen |
            TokenType::KeywordOverride | TokenType::KeywordAbstract | TokenType::KeywordInterface |
            TokenType::KeywordObject | TokenType::KeywordInline | TokenType::KeywordInfix |
            TokenType::KeywordOperator | TokenType::KeywordSuspend | TokenType::KeywordYield |
            
            // Reactive keywords
            TokenType::KeywordObservable | TokenType::KeywordFlow | TokenType::KeywordSubscribe |
            TokenType::KeywordEmit | TokenType::KeywordCollect |
            
            // Arabic keywords
            TokenType::KeywordDalah | TokenType::KeywordAjel | TokenType::KeywordMotghaier |
            TokenType::KeywordIdha | TokenType::KeywordWillah | TokenType::KeywordBeynama |
            TokenType::KeywordLekol | TokenType::KeywordFi | TokenType::KeywordArje |
            TokenType::KeywordAksir | TokenType::KeywordWasil | TokenType::KeywordSifa |
            TokenType::KeywordTatbiq | TokenType::KeywordBonya | TokenType::KeywordTaadod |
            TokenType::KeywordTaybiq | TokenType::KeywordEstirad | TokenType::KeywordTasdir |
            TokenType::KeywordKama | TokenType::KeywordSahih | TokenType::KeywordKhatae => true,
            
            _ => false,
        }
    }
    
    // Check if token is a literal
    fun is_literal(self) -> bool {
        match self {
            TokenType::IntegerLiteral | TokenType::FloatLiteral | 
            TokenType::StringLiteral | TokenType::CharLiteral | 
            TokenType::BooleanLiteral => true,
            _ => false,
        }
    }
    
    // Check if token is an operator
    fun is_operator(self) -> bool {
        match self {
            TokenType::Plus | TokenType::Minus | TokenType::Star | TokenType::Slash |
            TokenType::Percent | TokenType::Equal | TokenType::EqualEqual |
            TokenType::BangEqual | TokenType::Less | TokenType::LessEqual |
            TokenType::Greater | TokenType::GreaterEqual | TokenType::Bang |
            TokenType::Ampersand | TokenType::AmpersandAmpersand | TokenType::Pipe |
            TokenType::PipePipe | TokenType::Caret | TokenType::Tilde |
            TokenType::LeftShift | TokenType::RightShift => true,
            _ => false,
        }
    }
    
    // Get operator precedence (lower number = higher precedence)
    fun precedence(self) -> i32 {
        match self {
            TokenType::Star | TokenType::Slash | TokenType::Percent => 1,
            TokenType::Plus | TokenType::Minus => 2,
            TokenType::LeftShift | TokenType::RightShift => 3,
            TokenType::Less | TokenType::LessEqual | 
            TokenType::Greater | TokenType::GreaterEqual => 4,
            TokenType::EqualEqual | TokenType::BangEqual => 5,
            TokenType::Ampersand => 6,
            TokenType::Caret => 7,
            TokenType::Pipe => 8,
            TokenType::AmpersandAmpersand => 9,
            TokenType::PipePipe => 10,
            TokenType::Equal => 11,
            _ => 100, // Lowest precedence
        }
    }
    
    // Convert token type to string representation
    fun to_string(self) -> str {
        match self {
            TokenType::EOF => "EOF",
            TokenType::Identifier => "identifier",
            TokenType::IntegerLiteral => "integer",
            TokenType::FloatLiteral => "float",
            TokenType::StringLiteral => "string",
            TokenType::CharLiteral => "char",
            TokenType::BooleanLiteral => "boolean",
            TokenType::KeywordFun => "fun",
            TokenType::KeywordLet => "let",
            TokenType::KeywordMut => "mut",
            TokenType::Plus => "+",
            TokenType::Minus => "-",
            TokenType::Star => "*",
            TokenType::Slash => "/",
            TokenType::LeftParen => "(",
            TokenType::RightParen => ")",
            TokenType::LeftBrace => "{",
            TokenType::RightBrace => "}",
            // Add more as needed...
            _ => "unknown",
        }
    }
}

impl Token {
    // Create new token
    fun new(token_type: TokenType, lexeme: str, line: i32, column: i32) -> Self {
        Self { token_type, lexeme, line, column }
    }
    
    // Check if token matches specific type
    fun is_type(self, token_type: TokenType) -> bool {
        self.token_type == token_type
    }
    
    // Get token location as string
    fun location(self) -> str {
        format!("{}:{}", self.line, self.column)
    }
    
    // Convert token to string representation
    fun to_string(self) -> str {
        format!("{} '{}' at {}", self.token_type.to_string(), self.lexeme, self.location())
    }
}