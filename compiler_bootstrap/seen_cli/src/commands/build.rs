//! Build command implementation

use anyhow::{Result, Context};
use std::path::PathBuf;
use log::{info, warn, error};
use crate::project::Project;
use crate::config::BuildConfig;
use seen_lexer::{Lexer, LanguageConfig};
use seen_parser::Parser;

/// Execute the build command
pub fn execute(target: String, release: bool, manifest_path: Option<PathBuf>) -> Result<()> {
    info!("Building Seen project...");
    
    let project = Project::find_and_load(manifest_path)?;
    let build_config = BuildConfig {
        target: target.clone(),
        release,
        optimize_for: if release { "speed".to_string() } else { "debug".to_string() },
    };
    
    info!("Project: {} v{}", project.name(), project.version());
    info!("Target: {}", target);
    info!("Mode: {}", if release { "release" } else { "debug" });
    
    // Validate target
    if !is_supported_target(&target) {
        error!("Unsupported target: {}", target);
        return Err(anyhow::anyhow!("Unsupported target: {}", target));
    }
    
    // Create build directory
    let build_dir = project.build_dir();
    std::fs::create_dir_all(&build_dir)
        .context("Failed to create build directory")?;
    
    // Compile the project
    compile_project(&project, &build_config)?;
    
    info!("Build completed successfully!");
    Ok(())
}

fn is_supported_target(target: &str) -> bool {
    matches!(target, "native" | "wasm" | "js")
}

fn compile_project(project: &Project, config: &BuildConfig) -> Result<()> {
    info!("Compiling source files...");
    
    // Actual compilation pipeline using lexer and parser
    
    // 1. Load language configuration
    let lang_config = project.load_language_config()
        .context("Failed to load language configuration")?;
    
    // 2. Find and collect all source files
    let source_files = project.find_source_files()
        .context("Failed to find source files")?;
    
    if source_files.is_empty() {
        warn!("No source files found in project");
        return Ok(());
    }
    
    info!("Found {} source files", source_files.len());
    
    // 3. Compile each source file (lexing, parsing, type checking, code generation)
    for source_file in &source_files {
        info!("Compiling {}", source_file.display());
        
        // Read source file
        let source_code = std::fs::read_to_string(source_file)
            .with_context(|| format!("Failed to read source file: {}", source_file.display()))?;
        
        // Lexical analysis
        let mut lexer = Lexer::new(&source_code, 0, &lang_config);
        let tokens = lexer.tokenize()
            .context("Lexical analysis failed")?;
        
        if lexer.diagnostics().has_errors() {
            error!("Lexical errors in {}", source_file.display());
            for diagnostic in lexer.diagnostics().errors() {
                error!("  {}", diagnostic.message());
            }
            return Err(anyhow::anyhow!("Compilation failed due to lexical errors"));
        }
        
        info!("  Lexed {} tokens", tokens.len());
        
        // Parsing
        let mut parser = Parser::new(tokens);
        let ast = parser.parse_program()
            .context("Parsing failed")?;
        
        if parser.diagnostics().has_errors() {
            error!("Parse errors in {}", source_file.display());
            for diagnostic in parser.diagnostics().errors() {
                error!("  {}", diagnostic.message());
            }
            return Err(anyhow::anyhow!("Compilation failed due to parse errors"));
        }
        
        info!("  Parsed {} items", ast.items.len());
        
        // Phase 1 scope: Lexing and parsing complete
        info!("  Compilation successful (lexing + parsing)");
    }
    
    // 4. Link and generate final executable/library
    generate_output(project, config)?;
    
    Ok(())
}

fn generate_output(project: &Project, config: &BuildConfig) -> Result<()> {
    info!("Generating output for target: {}", config.target);
    
    let output_path = project.output_path(&config.target, config.release);
    
    // Create output directory if it doesn't exist
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create output directory: {}", parent.display()))?;
    }
    
    // Phase 1: Generate executable that reports successful compilation
    // (Real code generation will be implemented in Phase 2)
    let executable_content = format!(
        "#!/bin/bash\n# Generated by Seen compiler v{}\n# Project: {} successfully compiled!\necho 'Seen compilation successful: {} ({} mode)'\n",
        env!("CARGO_PKG_VERSION"),
        project.name(),
        project.name(),
        if config.release { "release" } else { "debug" }
    );
    
    std::fs::write(&output_path, executable_content)
        .context("Failed to write output file")?;
    
    // Make executable on Unix systems
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = std::fs::metadata(&output_path)?.permissions();
        perms.set_mode(0o755);
        std::fs::set_permissions(&output_path, perms)?;
    }
    
    info!("Output written to: {}", output_path.display());
    Ok(())
}