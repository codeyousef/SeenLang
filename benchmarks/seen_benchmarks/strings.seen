// Seen String Benchmark
// Tests string operations performance

fun benchmark_string_concatenation(iterations: i32) -> f64 {
    let start = std::time::now()
    let mut result = ""
    
    for i in 0..iterations {
        result = result + "test"
        if result.len() > 10000 {
            result = ""  // Reset to avoid memory issues
        }
    }
    
    let elapsed = std::time::now() - start
    let ops = iterations as f64
    return ops / elapsed.as_secs_f64()
}

fun benchmark_string_builder(iterations: i32) -> f64 {
    let start = std::time::now()
    
    for _ in 0..(iterations / 100) {
        let mut builder = StringBuilder::new()
        for _ in 0..100 {
            builder.append("test")
        }
        let _ = builder.to_string()
    }
    
    let elapsed = std::time::now() - start
    let ops = iterations as f64
    return ops / elapsed.as_secs_f64()
}

fun benchmark_string_parsing(iterations: i32) -> f64 {
    let test_strings = Vec::new()
    for i in 0..100 {
        test_strings.push(i.to_string())
    }
    
    let start = std::time::now()
    let mut sum = 0
    
    for i in 0..iterations {
        let str = test_strings[i % 100]
        let num = str.parse_i32().unwrap_or(0)
        sum = sum + num
    }
    
    let elapsed = std::time::now() - start
    let ops = iterations as f64
    return ops / elapsed.as_secs_f64()
}

fun benchmark_string_search(iterations: i32) -> f64 {
    let text = "The quick brown fox jumps over the lazy dog. " * 100
    let patterns = vec!["quick", "fox", "dog", "cat", "jumps"]
    
    let start = std::time::now()
    let mut count = 0
    
    for i in 0..iterations {
        let pattern = patterns[i % patterns.len()]
        if text.contains(pattern) {
            count = count + 1
        }
    }
    
    let elapsed = std::time::now() - start
    let ops = iterations as f64
    return ops / elapsed.as_secs_f64()
}

fun main() {
    let args = std::env::args()
    let iterations = if args.len() > 1 {
        args[1].parse_i32().unwrap_or(10000)
    } else {
        10000
    }
    
    println("=== Seen String Benchmarks ===")
    println("Iterations: " + iterations.to_string())
    println("")
    
    print("string_concatenation: ")
    let concat_ops = benchmark_string_concatenation(iterations)
    println(concat_ops.to_string() + " ops/sec")
    
    print("string_builder: ")
    let builder_ops = benchmark_string_builder(iterations)
    println(builder_ops.to_string() + " ops/sec")
    
    print("string_parsing: ")
    let parse_ops = benchmark_string_parsing(iterations)
    println(format_ops_per_sec(parse_ops))
    
    print("string_search: ")
    let search_ops = benchmark_string_search(iterations)
    println(format_ops_per_sec(search_ops))
    
    if args.len() > 2 {
        let output_file = args[2]
        let json = "{
  \"language\": \"Seen\",
  \"iterations\": " + iterations.to_string() + ",
  \"benchmarks\": {
    \"string_concatenation\": " + concat_ops.to_string() + ",
    \"string_builder\": " + builder_ops.to_string() + ",
    \"string_parsing\": " + parse_ops.to_string() + ",
    \"string_search\": " + search_ops.to_string() + "
  }
}"
        std::fs::write_string(output_file, json)
        println("\nResults saved to: " + output_file)
    }
}

fun format_ops_per_sec(ops: f64) -> String {
    if ops > 1000000.0 {
        return (ops / 1000000.0).to_string() + " million ops/sec"
    } else {
        return ops.to_string() + " ops/sec"
    }
}