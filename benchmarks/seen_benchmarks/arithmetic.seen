// Seen Arithmetic Benchmark
// Equivalent to Rust/C++ arithmetic benchmarks for fair comparison

fun benchmark_i32_addition(iterations: i32) -> f64 {
    let start = std::time::now()
    let mut sum: i32 = 0
    
    for i in 0..iterations {
        sum = sum + i
        sum = sum + (i * 2)
        sum = sum + (i / 2)
    }
    
    let elapsed = std::time::now() - start
    let ops = (iterations * 3) as f64
    return ops / elapsed.as_secs_f64()
}

fun benchmark_i32_multiplication(iterations: i32) -> f64 {
    let start = std::time::now()
    let mut product: i32 = 1
    
    for i in 1..iterations {
        product = product * 2
        product = product / 2
        product = product * 3
        product = product / 3
    }
    
    let elapsed = std::time::now() - start
    let ops = (iterations * 4) as f64
    return ops / elapsed.as_secs_f64()
}

fun benchmark_f64_operations(iterations: i32) -> f64 {
    let start = std::time::now()
    let mut result: f64 = 1.0
    
    for i in 0..iterations {
        let x = i as f64
        result = result + x
        result = result * 1.01
        result = result / 1.01
        result = result - x * 0.5
    }
    
    let elapsed = std::time::now() - start
    let ops = (iterations * 4) as f64
    return ops / elapsed.as_secs_f64()
}

fun benchmark_bitwise_operations(iterations: i32) -> f64 {
    let start = std::time::now()
    let mut result: i32 = 0
    
    for i in 0..iterations {
        result = result ^ i
        result = result | (i & 0xFF)
        result = result & (i | 0xFF00)
        result = result ^ (i << 2)
        result = result | (i >> 2)
    }
    
    let elapsed = std::time::now() - start
    let ops = (iterations * 5) as f64
    return ops / elapsed.as_secs_f64()
}

fun main() {
    // Get iterations from command line or use default
    let args = std::env::args()
    let iterations = if args.len() > 1 {
        args[1].parse_i32().unwrap_or(1000000)
    } else {
        1000000
    }
    
    println("=== Seen Arithmetic Benchmarks ===")
    println("Iterations: " + iterations.to_string())
    println("")
    
    // Run benchmarks
    print("i32_addition: ")
    let i32_add_ops = benchmark_i32_addition(iterations)
    println(format_ops_per_sec(i32_add_ops))
    
    print("i32_multiplication: ")
    let i32_mul_ops = benchmark_i32_multiplication(iterations)
    println(format_ops_per_sec(i32_mul_ops))
    
    print("f64_operations: ")
    let f64_ops = benchmark_f64_operations(iterations)
    println(format_ops_per_sec(f64_ops))
    
    print("bitwise_operations: ")
    let bitwise_ops = benchmark_bitwise_operations(iterations)
    println(format_ops_per_sec(bitwise_ops))
    
    // Save results if output file specified
    if args.len() > 2 {
        let output_file = args[2]
        let json = generate_json_report(
            i32_add_ops,
            i32_mul_ops,
            f64_ops,
            bitwise_ops,
            iterations
        )
        std::fs::write_string(output_file, json)
        println("\nResults saved to: " + output_file)
    }
}

fun format_ops_per_sec(ops: f64) -> String {
    if ops > 1000000000.0 {
        return (ops / 1000000000.0).to_string() + " billion ops/sec"
    } else if ops > 1000000.0 {
        return (ops / 1000000.0).to_string() + " million ops/sec"
    } else {
        return ops.to_string() + " ops/sec"
    }
}

fun generate_json_report(
    i32_add: f64,
    i32_mul: f64,
    f64_ops: f64,
    bitwise: f64,
    iterations: i32
) -> String {
    return "{
  \"language\": \"Seen\",
  \"iterations\": " + iterations.to_string() + ",
  \"benchmarks\": {
    \"i32_addition\": " + i32_add.to_string() + ",
    \"i32_multiplication\": " + i32_mul.to_string() + ",
    \"f64_operations\": " + f64_ops.to_string() + ",
    \"bitwise_operations\": " + bitwise.to_string() + "
  }
}"
}